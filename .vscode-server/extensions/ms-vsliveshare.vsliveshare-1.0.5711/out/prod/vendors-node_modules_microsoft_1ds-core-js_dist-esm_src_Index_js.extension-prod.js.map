{"version":3,"file":"vendors-node_modules_microsoft_1ds-core-js_dist-esm_src_Index_js.extension-prod.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACgF;AAChF;AACA;AACA;AACA;AACA;AACwI;AACxE;AACV;AACtD;AACA;AACA;AACA,IAAI,iFAAS;AACb;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA,mCAAmC,oFAAgB,GAAG,wDAAwD;AAC9G;AACA;AACA,gBAAgB,8EAAM,sBAAsB,sCAAsC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAAU;AACtC;AACA,oCAAoC,kFAAU;AAC9C;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kFAAU;AAClC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+EAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,UAAU,kGAAkG,IAAI;AACjJ;AACA;AACA,gBAAgB,8EAAM,sBAAsB,iCAAiC;AAC7E;AACA;AACA;AACA,2DAA2D,+CAAO;AAClE,6BAA6B,iDAAS;AACtC;AACA;AACA;AACA;AACA,0CAA0C,qDAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,UAAU,YAAY,IAAI;AAC3D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,mFAAY;AACd,iEAAe,eAAe,EAAC;AAC/B;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACqD;AACpC;AACvE;AACA,IAAI,iFAAS;AACb;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAyB;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB,sFAAc,2IAA2I,+EAAO;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAiB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,4EAAY;AACd,iEAAe,QAAQ,EAAC;AACxB;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACd;AACtD;AACA;AACA;AACA;AACA,kBAAkB,8EAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6IAA6I;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAe,SAAS,EAAC;AACzB;;;;;;;;;;;;;;;;;AC7RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AAC+B;AACb;AACtD;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kDAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,iFAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAe,kBAAkB,EAAC;AAClC;;;;;;;;;;;;;;;;;;;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8E;AAC0B;AACxG;AACA;AACA;AACA;AACO,gBAAgB,uFAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,mBAAmB,uFAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,wBAAwB,uFAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,uBAAuB,uFAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,iBAAiB,uFAAe;AACvC;AACA;AACA;AACA;AACA,CAAC;AACM,iCAAiC,iFAAS,CAAC,gFAAQ,CAAC,gFAAQ,GAAG,EAAE,sFAAkB,GAAG,uFAAe;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+H;AAC/E;AACd;AACE;AACkB;AACJ;AACwI;AASge;AAIjoB;AACzB;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACoG;AAC1B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAQ,UAAU,gFAAQ;AAC9C;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gFAAQ,UAAU,yFAAiB;AACxD;AACA;AACA;AACA,gCAAgC,yDAAiB;AACjD;AACA;AACA;AACA,yBAAyB,uDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gFAAQ,UAAU,yFAAiB,eAAe,uDAAe;AAClF;AACA;AACA,4BAA4B,yDAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yFAAiB;AAClC,4HAA4H,mDAAW;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAe;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qFAAa;AACrC;AACA,gCAAgC,uDAAe;AAC/C;AACA,+FAA+F,yDAAiB;AAChH;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAiB;AACnD;AACA,CAAC;AACyB;AAC1B;;;;;;;;;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACyE;AAClE,sBAAsB,qFAAe;AAC5C;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,yBAAyB,qFAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACa;AACN;AACP;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACgF;AAC1C;AACsB;AACrB;AACe;AACA;AACQ;AAC9D;AACA,IAAI,iFAAS;AACb;AACA;AACA,QAAQ,sEAAY;AACpB;AACA,mEAAmE,+DAAgB,qCAAqC,qEAAmB;AAC3I;AACA;AACA,gBAAgB,oDAAM,mCAAmC,iCAAiC;AAC1F;AACA;AACA;AACA,wBAAwB,wDAAU;AAClC;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,UAAU,qBAAqB,IAAI;AACpE;AACA;AACA,oBAAoB,+DAAiB;AACrC;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,+CAAQ;AACiB;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACa;AAC2E;AACrB;AACb;AACyH;AAC3D;AACzD;AACb;AAC4J;AAChJ;AACiD;AACpD;AAC6D;AAC1C;AAChB;AACc;AAC2G;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAU;AACd,YAAY,+DAAiB,SAAS,+DAAiB;AACvD,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA,iBAAiB,+DAAiB;AAClC,gBAAgB,iEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAU;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,iFAAW,SAAS;AAC/B,WAAW,0EAA0B,2BAA2B;AAChE,WAAW,6EAA6B,2BAA2B;AACnE,WAAW,6DAAa,yBAAyB;AACjD,WAAW,kEAAkB,iCAAiC;AAC9D,WAAW,oEAAoB,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA,gDAAgD;AAChD;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA,+BAA+B,+DAAiB;AAChD,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,qFAAa,CAAC,qFAAa;AAC3F,8CAA8C;AAC9C;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA,qBAAqB;AACrB;AACA,uBAAuB,uDAAS;AAChC;AACA;AACA;AACA,gBAAgB,sDAAQ,gBAAgB,+CAAO,yCAAyC,qDAAW;AACnG;AACA,gBAAgB,sDAAQ,wBAAwB,yDAAW,oBAAoB,qDAAW;AAC1F;AACA,gBAAgB,sDAAQ,oCAAoC,2DAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,kBAAkB,0EAA0B;AAC5C;AACA,yCAAyC,0EAA0B;AACnE;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,kBAAkB,6EAA6B;AAC/C;AACA,yCAAyC,6EAA6B;AACtE;AACA;AACA;AACA;AACA,qCAAqC,2DAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wDAAU;AAChF;AACA;AACA;AACA,0DAA0D,2DAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAc,sBAAsB,qCAAqC;AACrF;AACA,0CAA0C;AAC1C;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6FAAmC;AAC1E;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iFAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAe,qCAAqC,yBAAyB;AACzF;AACA;AACA;AACA,+BAA+B,uDAAS,SAAS;AACjD,mCAAmC,+DAAgB;AACnD;AACA,kDAAkD,oFAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAqB;AACrD,kCAAkC,sFAA4B;AAC9D;AACA;AACA;AACA,uBAAuB,uFAA6B;AACpD;AACA;AACA;AACA;AACA,sEAAsE,0EAAyB;AAC/F;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAS,CAAC,wEAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAU;AACxC;AACA;AACA;AACA,0BAA0B,wDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kFAA6B;AACnE;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAW;AAC/C;AACA;AACA,gBAAgB,qEAAiB;AACjC;AACA,oCAAoC,uDAAS,CAAC,+DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAe,YAAY,2DAAW;AAClE,yBAAyB;AACzB;AACA,8CAA8C,mEAAe;AAC7D,gDAAgD,2DAAW,kBAAkB,2DAAW;AACxF,yBAAyB;AACzB;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAU;AAClC;AACA;AACA,mCAAmC,mFAAyB,CAAC,+DAAW;AACxE;AACA;AACA;AACA;AACA;AACA,sCAAsC,mFAAyB;AAC/D,oCAAoC,6FAAmC;AACvE;AACA;AACA;AACA;AACA,wBAAwB,wDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4BAA4B,wDAAU;AACtC;AACA,gCAAgC,wDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,kCAAkC,yDAAW;AAC7C,sCAAsC,2EAA4B;AAClE,wCAAwC;AACxC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6EAA6B;AACtE;AACA;AACA;AACA,qCAAqC,qEAAgB;AACrD,yCAAyC,0EAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA,gCAAgC,yDAAW,SAAS,0DAAkB;AACtE;AACA;AACA;AACA,gCAAgC,6FAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAc;AAClC;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;;;;;;;;;;;;;;;;;;;;ACtnBA;AACA;AACA;AACA;AACA;AACA;AAC2E;AACY;AACc;AAC9C;AAChD;AACP;AACA;AACA,iBAAiB,qDAAO;AACxB;AACA;AACA,SAAS;AACT,QAAQ,wDAAU;AAClB;AACA,gBAAgB,wDAAU;AAC1B;AACA,SAAS;AACT;AACA,mBAAmB,uDAAS;AAC5B,mBAAmB,mFAAyB;AAC5C,SAAS;AACT;AACA;AACO;AACP;AACA;AACA,eAAe,uFAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAc;AACnC,SAAS;AACT,sBAAsB,8DAAc;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAc;AACnC,SAAS;AACT,sBAAsB,8DAAc;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA,wBAAwB,oEAAiB,CAAC,uFAA6B;AACvE;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,8DAAc;AAC3C,iBAAiB;AACjB,4BAA4B,8DAAc;AAC1C,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT,WAAW,wDAAQ;AACnB;AACA;AACA,2BAA2B,wDAAQ,YAAY,wDAAQ;AACvD,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,WAAW,yDAAS;AACpB;AACA;AACA,2BAA2B,yDAAS,YAAY,yDAAS;AACzD,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,wDAAU,8BAA8B,6DAA6D;AAC7G;AACA;AACA;AACA;AACA,QAAQ,wDAAU;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3NA;AACA;AACA;AACA;AACsD;AACC;AACgH;AACvK;AACA,IAAI,wDAAU;AACd;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,QAAQ,sEAAY;AACpB,kBAAkB,0EAA0B;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,kBAAkB,6EAA6B;AAC/C,4BAA4B,wDAAU;AACtC;AACA;AACA,4BAA4B,wDAAU;AACtC;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA,kBAAkB,6DAAa;AAC/B,+CAA+C,6DAAa;AAC5D,6BAA6B,6DAAa;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,uBAAuB,QAAQ;AAC/B;AACA;AACA,kBAAkB,kEAAkB;AACpC,+CAA+C,kEAAkB;AACjE,6BAA6B,kEAAkB;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,SAAS;AAChC;AACA,kBAAkB,oEAAoB;AACtC,+CAA+C,oEAAoB;AACnE,6BAA6B,oEAAoB;AACjD,iBAAiB;AACjB;AACA,kBAAkB,4DAAY;AAC9B;AACA;AACA;AACA,uDAAuD,4DAAY;AACnE;AACA,yDAAyD,gBAAgB,4DAAY,eAAe;AACpG;AACA;AACA,yCAAyC,4DAAY;AACrD;AACA,yBAAyB;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC8B;AAC/B;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACgF;AAC1B;AACM;AACR;AACf;AACwB;AACT;AACpD;AACA,IAAI,iFAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAU;AAClC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAc,4LAA4L,8DAAgB,OAAO,WAAW,kDAAO,KAAK;AACpR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6DAAa;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,qEAAmB;AACiB;AACtC","sources":["../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/AppInsightsCore.js","../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/BaseCore.js","../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/ESPromise.js","../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/ESPromiseScheduler.js","../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/Enums.js","../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/Index.js","../../../node_modules/@microsoft/1ds-core-js/dist-esm/src/ValueSanitizer.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK.Enums/LoggingEnums.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK.Interfaces/IChannelControls.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/AppInsightsCore.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/BaseCore.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/ChannelController.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/NotificationManager.js","../../../node_modules/@microsoft/1ds-core-js/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/TelemetryInitializerPlugin.js"],"sourcesContent":["/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\nimport { __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\r\n/**\r\n * AppInsightsCore.ts\r\n * @author Abhilash Panwar (abpanwar) Hector Hernandez (hectorh)\r\n * @copyright Microsoft 2018\r\n */\r\nimport { AppInsightsCore as InternalCore, doPerf, arrForEach, dumpObj, DiagnosticLogger } from \"@microsoft/applicationinsights-core-js\";\r\nimport { isLatency, FullVersionString, getTime } from \"./Utils\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nvar PropVersion = \"version\";\r\nvar properties = \"properties\";\r\nvar AppInsightsCore = /** @class */ (function (_super) {\r\n    __extends(AppInsightsCore, _super);\r\n    function AppInsightsCore() {\r\n        var _this = _super.call(this) || this;\r\n        _this.pluginVersionStringArr = [];\r\n        _this.pluginVersionString = \"\";\r\n        dynamicProto(AppInsightsCore, _this, function (_self, _base) {\r\n            if (!_self.logger || !_self.logger.queue) {\r\n                // The AI Base can inject a No-Op logger so if not defined or the No-Op, change to use a default logger so initialization errors\r\n                // are not dropped on the floor if one is not already defined\r\n                _self.logger = new DiagnosticLogger({ loggingLevelConsole: 1 /* eLoggingSeverity.CRITICAL */ });\r\n            }\r\n            _self.initialize = function (config, extensions, logger, notificationManager) {\r\n                doPerf(_self, function () { return \"AppInsightsCore.initialize\"; }, function () {\r\n                    // Add default collector url\r\n                    if (config) {\r\n                        if (!config.endpointUrl) {\r\n                            config.endpointUrl = \"https://browser.events.data.microsoft.com/OneCollector/1.0/\";\r\n                        }\r\n                        var propertyStorageOverride = config.propertyStorageOverride;\r\n                        // Validate property storage override\r\n                        if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {\r\n                            throw new Error(\"Invalid property storage override passed.\");\r\n                        }\r\n                        if (config.channels) {\r\n                            arrForEach(config.channels, function (channels) {\r\n                                if (channels) {\r\n                                    arrForEach(channels, function (channel) {\r\n                                        if (channel.identifier && channel.version) {\r\n                                            var ver = channel.identifier + \"=\" + channel.version;\r\n                                            _self.pluginVersionStringArr.push(ver);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    _self.getWParam = function () {\r\n                        return typeof document !== \"undefined\" ? 0 : -1;\r\n                    };\r\n                    if (extensions) {\r\n                        arrForEach(extensions, function (ext) {\r\n                            if (ext && ext.identifier && ext.version) {\r\n                                var ver = ext.identifier + \"=\" + ext.version;\r\n                                _self.pluginVersionStringArr.push(ver);\r\n                            }\r\n                        });\r\n                    }\r\n                    _self.pluginVersionString = _self.pluginVersionStringArr.join(\";\");\r\n                    try {\r\n                        _base.initialize(config, extensions, logger, notificationManager);\r\n                        _self.pollInternalLogs(\"InternalLog\");\r\n                    }\r\n                    catch (e) {\r\n                        var logger_1 = _self.logger;\r\n                        var message = dumpObj(e);\r\n                        if (message.indexOf(\"channels\") !== -1) {\r\n                            // Add some additional context to the underlying reported error\r\n                            message += \"\\n - Channels must be provided through config.channels only!\";\r\n                        }\r\n                        logger_1.throwInternal(1 /* eLoggingSeverity.CRITICAL */, 514 /* _eExtendedInternalMessageId.FailedToInitializeSDK */, \"SDK Initialization Failed - no telemetry will be sent: \" + message);\r\n                    }\r\n                }, function () { return ({ config: config, extensions: extensions, logger: logger, notificationManager: notificationManager }); });\r\n            };\r\n            _self.track = function (item) {\r\n                doPerf(_self, function () { return \"AppInsightsCore.track\"; }, function () {\r\n                    var telemetryItem = item;\r\n                    if (telemetryItem) {\r\n                        telemetryItem.timings = telemetryItem.timings || {};\r\n                        telemetryItem.timings.trackStart = getTime();\r\n                        if (!isLatency(telemetryItem.latency)) {\r\n                            telemetryItem.latency = 1 /* EventLatencyValue.Normal */;\r\n                        }\r\n                        var itemExt = telemetryItem.ext = telemetryItem.ext || {};\r\n                        itemExt.sdk = itemExt.sdk || {};\r\n                        itemExt.sdk.ver = FullVersionString;\r\n                        var baseData = telemetryItem.baseData = telemetryItem.baseData || {};\r\n                        if (!baseData[properties]) {\r\n                            baseData[properties] = {};\r\n                        }\r\n                        var itemProperties = baseData[properties];\r\n                        if (!itemProperties[PropVersion]) {\r\n                            itemProperties[PropVersion] = \"\";\r\n                        }\r\n                        if (_self.pluginVersionString !== \"\") {\r\n                            itemProperties[PropVersion] = _self.pluginVersionString;\r\n                        }\r\n                    }\r\n                    _base.track(telemetryItem);\r\n                }, function () { return ({ item: item }); }, !(item.sync));\r\n            };\r\n        });\r\n        return _this;\r\n    }\r\n// Removed Stub for AppInsightsCore.prototype.initialize.\r\n// Removed Stub for AppInsightsCore.prototype.track.\r\n    return AppInsightsCore;\r\n}(InternalCore));\r\nexport default AppInsightsCore;\r\n//# sourceMappingURL=AppInsightsCore.js.map","/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\nimport { __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\r\n/**\r\n * BaseCore.ts\r\n * Base Core is a subset of 1DS Web SDK Core. The purpose of Base Core is to generate a smaller bundle size while providing essential features of Core. Features that are not included in Base Core are:\r\n * 1. Internal logging\r\n * 2. Sending notifications on telemetry sent/discarded\r\n * @author Abhilash Panwar (abpanwar) Hector Hernandez (hectorh)\r\n * @copyright Microsoft 2018\r\n */\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { BaseCore as InternalCore, dumpObj, _throwInternal } from \"@microsoft/applicationinsights-core-js\";\r\nimport { FullVersionString, isDocumentObjectAvailable } from \"./Utils\";\r\nvar BaseCore = /** @class */ (function (_super) {\r\n    __extends(BaseCore, _super);\r\n    function BaseCore() {\r\n        var _this = _super.call(this) || this;\r\n        dynamicProto(BaseCore, _this, function (_self, _base) {\r\n            _self.initialize = function (config, extensions, logger, notificationManager) {\r\n                if (config && !config.endpointUrl) {\r\n                    config.endpointUrl = \"https://browser.events.data.microsoft.com/OneCollector/1.0/\";\r\n                }\r\n                _self.getWParam = function () {\r\n                    return isDocumentObjectAvailable ? 0 : -1;\r\n                };\r\n                try {\r\n                    _base.initialize(config, extensions, logger, notificationManager);\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(_self.logger, 1 /* eLoggingSeverity.CRITICAL */, 514 /* _eExtendedInternalMessageId.FailedToInitializeSDK */, \"Initialization Failed: \" + dumpObj(e) + \"\\n - Note: Channels must be provided through config.channels only\");\r\n                }\r\n            };\r\n            _self.track = function (item) {\r\n                var telemetryItem = item;\r\n                if (telemetryItem) {\r\n                    var ext = telemetryItem.ext = telemetryItem.ext || {};\r\n                    ext.sdk = ext.sdk || {};\r\n                    ext.sdk.ver = FullVersionString;\r\n                }\r\n                _base.track(telemetryItem);\r\n            };\r\n        });\r\n        return _this;\r\n    }\r\n// Removed Stub for BaseCore.prototype.initialize.\r\n// Removed Stub for BaseCore.prototype.track.\r\n    return BaseCore;\r\n}(InternalCore));\r\nexport default BaseCore;\r\n//# sourceMappingURL=BaseCore.js.map","/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n * ESPromise.ts\r\n * @author  Nev Wylie (newylie))\r\n * @copyright Microsoft 2019\r\n * Simplified wrapper to provide ES6 style Promise callback handling for older browsers\r\n */\r\nimport { isFunction } from \"@microsoft/applicationinsights-core-js\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * Using a local variable to assist with minfication\r\n */\r\nvar _isFunction = isFunction;\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * This function will be used as onFulfilled handler for any Promise found in the iterable passed to Promise.all.\r\n * The goal here is to capture in a closure the index of the current item from the iterable. If we did not create\r\n * this closure, the captured index variable would be the same one that the for loop updates and thus would always\r\n * be pointing to the last index in the iterable by the time that the onFulfilled handler is called.\r\n * However, note that for the resolvedCallback callback we want the opposite. For this one we do want to capture\r\n * the same variable that the for loop updates so that we have the full count of pending promises by the time\r\n * the onFulfilled handlers start getting called.\r\n * @param values The resolving promise values\r\n * @param index The index of this callback function\r\n * @param resolvedCallback THe callback function used to check if the \"all\" promise is complete\r\n */\r\nfunction _createPromiseAllOnResolvedFunction(values, index, resolvedCallback) {\r\n    return function (value) {\r\n        values[index] = value;\r\n        resolvedCallback();\r\n    };\r\n}\r\n/**\r\n * Simplified wrapper to provide ES6 style Promise callback handling for older browsers\r\n */\r\nvar ESPromise = /** @class */ (function () {\r\n    /**\r\n     * The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.\r\n     * @param resolverFunc A function that is passed with the arguments resolve and reject. The executor function is executed\r\n     * immediately by the Promise implementation, passing resolve and reject functions (the executor is called before the Promise\r\n     * constructor even returns the created object). The resolve and reject functions, when called, resolve or reject the promise,\r\n     * respectively. The executor normally initiates some asynchronous work, and then, once that completes, either calls the resolve\r\n     * function to resolve the promise or else rejects it if an error occurred. If an error is thrown in the executor function, the\r\n     * promise is rejected. The return value of the executor is ignored.\r\n     */\r\n    function ESPromise(resolverFunc) {\r\n        var _state = 0 /* PromiseState.Pending */;\r\n        var _settledValue = null;\r\n        var _queue = [];\r\n        dynamicProto(ESPromise, this, function (_this) {\r\n            _this.then = function (onResolved, onRejected) {\r\n                return new ESPromise(function (resolve, reject) {\r\n                    // Queue the new promise returned to be resolved or rejected\r\n                    // when this promise settles.\r\n                    _enqueue(onResolved, onRejected, resolve, reject);\r\n                });\r\n            };\r\n            _this[\"catch\"] = function (onRejected) {\r\n                return _this.then(null, onRejected);\r\n            };\r\n        });\r\n        function _enqueue(onResolved, onRejected, resolve, reject) {\r\n            _queue.push(function () {\r\n                var value;\r\n                try {\r\n                    // First call the onFulfilled or onRejected handler, on the settled value\r\n                    // of this promise. If the corresponding handler does not exist, simply\r\n                    // pass through the settled value.\r\n                    if (_state === 1 /* PromiseState.Resolved */) {\r\n                        value = _isFunction(onResolved) ? onResolved(_settledValue) : _settledValue;\r\n                    }\r\n                    else {\r\n                        value = _isFunction(onRejected) ? onRejected(_settledValue) : _settledValue;\r\n                    }\r\n                    if (value instanceof ESPromise) {\r\n                        // The called handlers returned a new promise, so the chained promise\r\n                        // will follow the state of this promise.\r\n                        value.then(resolve, reject);\r\n                    }\r\n                    else if (_state === 2 /* PromiseState.Rejected */ && !_isFunction(onRejected)) {\r\n                        // If there wasn't an onRejected handler and this promise is rejected, then\r\n                        // the chained promise also rejects with the same reason.\r\n                        reject(value);\r\n                    }\r\n                    else {\r\n                        // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                        // with either the settled value of this promise (if no onFulfilled handler\r\n                        // was available) or the return value of the handler. If this promise is\r\n                        // rejected and there was an onRejected handler, then the chained promise is\r\n                        // fulfilled with the return value of the handler.\r\n                        resolve(value);\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    // The chained promise will reject if there is any exception thrown while\r\n                    // calling the onFulfilled or onRejected handlers.\r\n                    reject(error);\r\n                    return;\r\n                }\r\n            });\r\n            // If this promise is already settled, then immediately process the callback we\r\n            // just added to the queue.\r\n            if (_state !== 0 /* PromiseState.Pending */) {\r\n                _processQueue();\r\n            }\r\n        }\r\n        function _processQueue() {\r\n            if (_queue.length > 0) {\r\n                // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n                // we make a copy of the queue and work on it once the current call stack unwinds.\r\n                var pending_1 = _queue.slice();\r\n                _queue = [];\r\n                setTimeout(function () {\r\n                    for (var i = 0, len = pending_1.length; i < len; ++i) {\r\n                        try {\r\n                            pending_1[i]();\r\n                        }\r\n                        catch (e) {\r\n                            // Don't let 1 failing handler break all others\r\n                            // TODO (newylie): Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n                        }\r\n                    }\r\n                }, 0);\r\n            }\r\n        }\r\n        function _resolve(value) {\r\n            if (_state === 0 /* PromiseState.Pending */) {\r\n                _settledValue = value;\r\n                _state = 1 /* PromiseState.Resolved */;\r\n                _processQueue();\r\n            }\r\n        }\r\n        function _reject(reason) {\r\n            if (_state === 0 /* PromiseState.Pending */) {\r\n                _settledValue = reason;\r\n                _state = 2 /* PromiseState.Rejected */;\r\n                _processQueue();\r\n            }\r\n        }\r\n        (function _initialize() {\r\n            if (!_isFunction(resolverFunc)) {\r\n                throw new TypeError(\"ESPromise: resolvedFunc argument is not a Function\");\r\n            }\r\n            try {\r\n                resolverFunc(_resolve, _reject);\r\n            }\r\n            catch (error) {\r\n                // This promise will immediately reject if any exception is thrown\r\n                // from within the executor function.\r\n                _reject(error);\r\n            }\r\n        })();\r\n    }\r\n    /**\r\n     * The Promise.resolve() method returns a Promise object that is resolved with a given value. If the value is a promise, that promise is returned;\r\n     * if the value is a thenable (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual state; otherwise\r\n     * the returned promise will be fulfilled with the value. This function flattens nested layers of promise-like objects (e.g. a promise that resolves\r\n     * to a promise that resolves to something) into a single layer.\r\n     * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n     */\r\n    ESPromise.resolve = function (value) {\r\n        if (value instanceof ESPromise) {\r\n            // Value is a Promise so just return it\r\n            return value;\r\n        }\r\n        else if (value && _isFunction(value.then)) {\r\n            // Value looks like a promise or thenable (has a then function)\r\n            return new ESPromise(function (resolve, reject) {\r\n                try {\r\n                    value.then(resolve, reject);\r\n                }\r\n                catch (error) {\r\n                    reject(error);\r\n                }\r\n            });\r\n        }\r\n        return new ESPromise(function (resolve) {\r\n            resolve(value);\r\n        });\r\n    };\r\n    /**\r\n     * The Promise.reject() method returns a Promise object that is rejected with a given reason.\r\n     * @param reason The reason why this Promise rejected.\r\n     */\r\n    ESPromise.reject = function (reason) {\r\n        return new ESPromise(function (resolve, reject) {\r\n            reject(reason);\r\n        });\r\n    };\r\n    /**\r\n     * The Promise.all() method returns a single Promise that resolves when all of the promises passed as an iterable\r\n     * have resolved or when the iterable contains no promises. It rejects with the reason of the first promise that\r\n     * rejects. There is no implied ordering in the execution of the array of Promises given. On some computers, they\r\n     * may be executed in parallel, or in some sense concurrently, while on others they may be executed serially. For\r\n     * this reason, there must be no dependency in any Promise on the order of execution of the Promises.\r\n     * This method can be useful for aggregating the results of multiple promises.\r\n     * FulfillmentSection - The returned promise is fulfilled with an array containing all the values of the iterable\r\n     * passed as argument (also non-promise values).\r\n     * If an empty iterable is passed, then this method returns (synchronously) an already resolved promise.\r\n     * If all of the passed-in promises fulfill, or are not promises, the promise returned by Promise.all is fulfilled\r\n     * asynchronously.\r\n     * RejectionSection - If any of the passed-in promises reject, Promise.all asynchronously rejects with the value of\r\n     * the promise that rejected, whether or not the other promises have resolved.\r\n     * @param iterable\r\n     */\r\n    ESPromise.all = function (iterable) {\r\n        if (!iterable || !iterable.length) {\r\n            return;\r\n        }\r\n        return new ESPromise(function (resolve, reject) {\r\n            try {\r\n                var values_1 = [];\r\n                var pending_2 = 0;\r\n                for (var lp = 0; lp < iterable.length; lp++) {\r\n                    var item = iterable[lp];\r\n                    // Quick and direct check for a Promise (will also catch a thenable)\r\n                    if (item && _isFunction(item.then)) {\r\n                        pending_2++;\r\n                        item.then(_createPromiseAllOnResolvedFunction(values_1, lp, function () {\r\n                            if (--pending_2 === 0) {\r\n                                resolve(values_1);\r\n                            }\r\n                        }), reject);\r\n                    }\r\n                    else {\r\n                        values_1[lp] = item;\r\n                    }\r\n                }\r\n                if (pending_2 === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    setTimeout(function () {\r\n                        resolve(values_1);\r\n                    }, 0);\r\n                }\r\n            }\r\n            catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * The race function returns a Promise that is settled the same way (and takes the same value) as the first promise\r\n     * that settles amongst the promises of the iterable passed as an argument.\r\n     * If the iterable passed is empty, the promise returned will be forever pending.\r\n     * If the iterable contains one or more non-promise value and/or an already settled promise, then Promise.race will\r\n     * resolve to the first of these values found in the iterable.\r\n     * @param iterable\r\n     */\r\n    ESPromise.race = function (iterable) {\r\n        return new ESPromise(function (resolve, reject) {\r\n            if (!iterable || !iterable.length) {\r\n                return;\r\n            }\r\n            try {\r\n                var _loop_1 = function (lp) {\r\n                    var item = iterable[lp];\r\n                    // Quick and direct check for a Promise (will also catch a thenable)\r\n                    if (item && _isFunction(item.then)) {\r\n                        item.then(resolve, reject);\r\n                    }\r\n                    else {\r\n                        setTimeout(function () {\r\n                            resolve(item);\r\n                        }, 0);\r\n                    }\r\n                };\r\n                for (var lp = 0; lp < iterable.length; lp++) {\r\n                    _loop_1(lp);\r\n                }\r\n            }\r\n            catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    };\r\n// Removed Stub for ESPromise.prototype.then.\r\n// Removed Stub for ESPromise.prototype[\"catch\"].\r\n    return ESPromise;\r\n}());\r\nexport default ESPromise;\r\n//# sourceMappingURL=ESPromise.js.map","/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n * ESPromiseScheduler.ts\r\n * @author Nev Wylie (newylie)\r\n * @copyright Microsoft 2019\r\n */\r\nimport ESPromise from \"./ESPromise\";\r\nimport { getGlobal } from \"@microsoft/applicationinsights-core-js\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\n/** This is a default timeout that will cause outstanding running promises to be removed/rejected to avoid filling up memory with blocked events */\r\nvar LazyRejectPeriod = 600000; // 10 Minutes\r\n// These are global variables that are shared across ALL instances of the scheduler\r\n/**\r\n * @ignore\r\n */\r\nvar _schedulerId = 0;\r\n/**\r\n * @ignore\r\n */\r\nvar _running = [];\r\n/**\r\n * @ignore\r\n */\r\nvar _waiting = [];\r\n/**\r\n * @ignore\r\n */\r\nvar _timedOut = [];\r\n/**\r\n * @ignore\r\n */\r\nfunction _getTime() {\r\n    return new Date().getTime();\r\n}\r\n/**\r\n * Provides a simple mechanism queueing mechanism for scheduling events based on the ESPromise callbacks, this is used to ensure\r\n * order of async operations that are required to be executed in a specific order.\r\n */\r\nvar ESPromiseScheduler = /** @class */ (function () {\r\n    function ESPromiseScheduler(name, diagLog) {\r\n        var _promiseId = 0;\r\n        var _scheduledName = (name || \"<unnamed>\") + \".\" + _schedulerId;\r\n        _schedulerId++;\r\n        dynamicProto(ESPromiseScheduler, this, function (_this) {\r\n            var _lastEvent = null;\r\n            var _eventCount = 0;\r\n            _this.scheduleEvent = function (startEventAction, eventName, timeout) {\r\n                var uniqueId = _scheduledName + \".\" + _eventCount;\r\n                _eventCount++;\r\n                if (eventName) {\r\n                    uniqueId += \"-(\" + eventName + \")\";\r\n                }\r\n                var uniqueEventId = uniqueId + \"{\" + _promiseId + \"}\";\r\n                _promiseId++;\r\n                // Create the next scheduled event details\r\n                var newScheduledEvent = {\r\n                    evt: null,\r\n                    tm: _getTime(),\r\n                    id: uniqueEventId,\r\n                    isRunning: false,\r\n                    isAborted: false\r\n                };\r\n                if (!_lastEvent) {\r\n                    // We don't have any currently running event, so just start the next event\r\n                    newScheduledEvent.evt = _startWaitingEvent(newScheduledEvent);\r\n                }\r\n                else {\r\n                    // Start a new promise which will wait until all current active events are complete before starting\r\n                    // the new event, it does not resolve this scheduled event until after the new event is resolve to\r\n                    // ensure that all scheduled events are completed in the correct order\r\n                    newScheduledEvent.evt = _waitForPreviousEvent(newScheduledEvent, _lastEvent);\r\n                }\r\n                // Set this new event as the last one, so that any future events will wait for this one\r\n                _lastEvent = newScheduledEvent;\r\n                _lastEvent.evt._schId = uniqueEventId;\r\n                return newScheduledEvent.evt;\r\n                function _abortAndRemoveOldEvents(eventQueue) {\r\n                    var now = _getTime();\r\n                    var expired = now - LazyRejectPeriod;\r\n                    var len = eventQueue.length;\r\n                    var lp = 0;\r\n                    while (lp < len) {\r\n                        var evt = eventQueue[lp];\r\n                        if (evt && evt.tm < expired) {\r\n                            var message = null;\r\n                            if (evt.abort) {\r\n                                message = \"Aborting [\" + evt.id + \"] due to Excessive runtime (\" + (now - evt.tm) + \" ms)\";\r\n                                evt.abort(message);\r\n                            }\r\n                            else {\r\n                                message = \"Removing [\" + evt.id + \"] due to Excessive runtime (\" + (now - evt.tm) + \" ms)\";\r\n                            }\r\n                            _warnLog(message);\r\n                            eventQueue.splice(lp, 1);\r\n                            len--;\r\n                        }\r\n                        else {\r\n                            lp++;\r\n                        }\r\n                    }\r\n                }\r\n                function _cleanup(eventId, completed) {\r\n                    var toQueue = false;\r\n                    var removed = _removeQueuedEvent(_running, eventId);\r\n                    if (!removed) {\r\n                        removed = _removeQueuedEvent(_timedOut, eventId);\r\n                        toQueue = true;\r\n                    }\r\n                    if (removed) {\r\n                        if (removed.to) {\r\n                            // If there was a timeout stop it\r\n                            clearTimeout(removed.to);\r\n                            removed.to = null;\r\n                        }\r\n                        // TODO (newylie): Convert this into reportable metrics\r\n                        var tm = _getTime() - removed.tm;\r\n                        if (completed) {\r\n                            if (!toQueue) {\r\n                                _debugLog(\"Promise [\" + eventId + \"] Complete -- \" + tm + \" ms\");\r\n                            }\r\n                            else {\r\n                                _warnLog(\"Timed out event [\" + eventId + \"] finally complete -- \" + tm + \" ms\");\r\n                            }\r\n                        }\r\n                        else {\r\n                            _timedOut.push(removed);\r\n                            _warnLog(\"Event [\" + eventId + \"] Timed out and removed -- \" + tm + \" ms\");\r\n                        }\r\n                    }\r\n                    else {\r\n                        _debugLog(\"Failed to remove [\" + eventId + \"] from running queue\");\r\n                    }\r\n                    // Also if the last scheduled event was this event then clear it as we are now finished\r\n                    if (_lastEvent && _lastEvent.id === eventId) {\r\n                        _lastEvent = null;\r\n                    }\r\n                    _abortAndRemoveOldEvents(_running);\r\n                    _abortAndRemoveOldEvents(_waiting);\r\n                    _abortAndRemoveOldEvents(_timedOut);\r\n                }\r\n                // Return a callback function that will be called when the waiting promise is resolved or rejected to ensure\r\n                // that any outer promise is also resolved or rejected\r\n                function _removeScheduledEvent(eventId, callback) {\r\n                    return function (value) {\r\n                        _cleanup(eventId, true);\r\n                        callback && callback(value);\r\n                        return value;\r\n                    };\r\n                }\r\n                function _waitForFinalResult(eventId, startResult, schEventResolve, schEventReject) {\r\n                    startResult.then(function (value) {\r\n                        if (value instanceof ESPromise) {\r\n                            // If the result is a promise then this appears to be a chained result, so wait for this promise to complete\r\n                            _debugLog(\"Event [\" + eventId + \"] returned a promise -- waiting\");\r\n                            _waitForFinalResult(eventId, value, schEventResolve, schEventReject);\r\n                            return value;\r\n                        }\r\n                        else {\r\n                            return _removeScheduledEvent(eventId, schEventResolve)(value);\r\n                        }\r\n                    }, _removeScheduledEvent(eventId, schEventReject));\r\n                }\r\n                // Add the passed event to the active event list with resolve and reject callbacks that will remove\r\n                // it from the active event list\r\n                function _createScheduledEvent(eventDetails, startEvent) {\r\n                    var eventId = eventDetails.id;\r\n                    return new ESPromise(function (schEventResolve, schEventReject) {\r\n                        _debugLog(\"Event [\" + eventId + \"] Starting -- waited for \" + (eventDetails.wTm || \"--\") + \" ms\");\r\n                        eventDetails.isRunning = true;\r\n                        eventDetails.abort = function (message) {\r\n                            eventDetails.abort = null;\r\n                            eventDetails.isAborted = true;\r\n                            _cleanup(eventId, false);\r\n                            schEventReject(new Error(message));\r\n                        };\r\n                        var startResult = startEvent(eventId);\r\n                        if (startResult instanceof ESPromise) {\r\n                            if (timeout) {\r\n                                // Note: Only starting a timer if a timeout was specified\r\n                                eventDetails.to = setTimeout(function () {\r\n                                    _cleanup(eventId, false);\r\n                                    // Cause the listeners to reject (Note: We can't actually reject the waiting event)\r\n                                    schEventReject(new Error(\"Timed out after [\" + timeout + \"] ms\"));\r\n                                }, timeout);\r\n                            }\r\n                            _waitForFinalResult(eventId, startResult, function (theResult) {\r\n                                _debugLog(\"Event [\" + eventId + \"] Resolving after \" + (_getTime() - eventDetails.tm) + \" ms\");\r\n                                schEventResolve(theResult);\r\n                            }, schEventReject);\r\n                        }\r\n                        else {\r\n                            // The startEvent didn't return a promise so just return a resolved promise\r\n                            _debugLog(\"Promise [\" + eventId + \"] Auto completed as the start action did not return a promise\");\r\n                            schEventResolve();\r\n                        }\r\n                    });\r\n                }\r\n                function _startWaitingEvent(eventDetails) {\r\n                    var now = _getTime();\r\n                    eventDetails.wTm = now - eventDetails.tm;\r\n                    eventDetails.tm = now;\r\n                    if (eventDetails.isAborted) {\r\n                        return ESPromise.reject(new Error(\"[\" + uniqueId + \"] was aborted\"));\r\n                    }\r\n                    _running.push(eventDetails);\r\n                    return _createScheduledEvent(eventDetails, startEventAction);\r\n                }\r\n                // Start a new promise which will wait until all current active events are complete before starting\r\n                // the new event, it does not resolve this scheduled event until after the new event is resolve to\r\n                // ensure that all scheduled events are completed in the correct order\r\n                function _waitForPreviousEvent(eventDetails, waitForEvent) {\r\n                    var waitEvent = new ESPromise(function (waitResolve, waitReject) {\r\n                        var runTime = _getTime() - waitForEvent.tm;\r\n                        var prevId = waitForEvent.id;\r\n                        _debugLog(\"[\" + uniqueId + \"] is waiting for [\" + prevId + \":\" + runTime + \" ms] to complete before starting -- [\" + _waiting.length + \"] waiting and [\" + _running.length + \"] running\");\r\n                        eventDetails.abort = function (message) {\r\n                            eventDetails.abort = null;\r\n                            _removeQueuedEvent(_waiting, uniqueId);\r\n                            eventDetails.isAborted = true;\r\n                            waitReject(new Error(message));\r\n                        };\r\n                        // Wait for the previous event to complete\r\n                        waitForEvent.evt.then(function (value) {\r\n                            _removeQueuedEvent(_waiting, uniqueId);\r\n                            // Wait for the last event to complete before starting the new one, this ensures the execution\r\n                            // order so that we don't try and remove events that havn't been committed yet\r\n                            _startWaitingEvent(eventDetails).then(waitResolve, waitReject);\r\n                        }, function (reason) {\r\n                            _removeQueuedEvent(_waiting, uniqueId);\r\n                            // Wait for the last event to complete before starting the new one, this ensures the execution\r\n                            // order so that we don't try and remove events that havn't been committed yet\r\n                            _startWaitingEvent(eventDetails).then(waitResolve, waitReject);\r\n                        });\r\n                    });\r\n                    _waiting.push(eventDetails);\r\n                    return waitEvent;\r\n                }\r\n            };\r\n            function _removeQueuedEvent(queue, eventId) {\r\n                for (var lp = 0; lp < queue.length; lp++) {\r\n                    if (queue[lp].id === eventId) {\r\n                        return queue.splice(lp, 1)[0];\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        function _debugLog(message) {\r\n            // Only log if running within test harness\r\n            var global = getGlobal();\r\n            if (global && global[\"QUnit\"]) {\r\n                // tslint:disable-next-line:no-console\r\n                console && console.log(\"ESPromiseScheduler[\" + _scheduledName + \"] \" + message);\r\n            }\r\n        }\r\n        function _warnLog(message) {\r\n            diagLog && diagLog.warnToConsole(\"ESPromiseScheduler[\" + _scheduledName + \"] \" + message);\r\n        }\r\n    }\r\n    ESPromiseScheduler.incomplete = function () {\r\n        return _running;\r\n    };\r\n    ESPromiseScheduler.waitingToStart = function () {\r\n        return _waiting;\r\n    };\r\n// Removed Stub for ESPromiseScheduler.prototype.scheduleEvent.\r\n    return ESPromiseScheduler;\r\n}());\r\nexport default ESPromiseScheduler;\r\n//# sourceMappingURL=ESPromiseScheduler.js.map","/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n * Enums.ts\r\n * @author Abhilash Panwar (abpanwar)\r\n * @copyright Microsoft 2018\r\n * File containing the enums as constants.\r\n */\r\nimport { __assignFn as __assign } from \"@microsoft/applicationinsights-shims\";\r\nimport { _InternalMessageId, createEnumStyle, objFreeze } from \"@microsoft/applicationinsights-core-js\";\r\n/**\r\n * The ValueKind contains a set of values that specify value kind of the property.\r\n * Either PII (Personal Identifiable Information) or customer content.\r\n */\r\nexport var ValueKind = createEnumStyle({\r\n    NotSet: 0 /* eValueKind.NotSet */,\r\n    Pii_DistinguishedName: 1 /* eValueKind.Pii_DistinguishedName */,\r\n    Pii_GenericData: 2 /* eValueKind.Pii_GenericData */,\r\n    Pii_IPV4Address: 3 /* eValueKind.Pii_IPV4Address */,\r\n    Pii_IPv6Address: 4 /* eValueKind.Pii_IPv6Address */,\r\n    Pii_MailSubject: 5 /* eValueKind.Pii_MailSubject */,\r\n    Pii_PhoneNumber: 6 /* eValueKind.Pii_PhoneNumber */,\r\n    Pii_QueryString: 7 /* eValueKind.Pii_QueryString */,\r\n    Pii_SipAddress: 8 /* eValueKind.Pii_SipAddress */,\r\n    Pii_SmtpAddress: 9 /* eValueKind.Pii_SmtpAddress */,\r\n    Pii_Identity: 10 /* eValueKind.Pii_Identity */,\r\n    Pii_Uri: 11 /* eValueKind.Pii_Uri */,\r\n    Pii_Fqdn: 12 /* eValueKind.Pii_Fqdn */,\r\n    Pii_IPV4AddressLegacy: 13 /* eValueKind.Pii_IPV4AddressLegacy */,\r\n    CustomerContent_GenericContent: 32 /* eValueKind.CustomerContent_GenericContent */\r\n});\r\n/**\r\n * The EventLatency contains a set of values that specify the latency with which an event is sent.\r\n */\r\nexport var EventLatency = createEnumStyle({\r\n    /**\r\n     * Normal latency.\r\n     */\r\n    Normal: 1 /* EventLatencyValue.Normal */,\r\n    /**\r\n     * Cost deferred latency. At the moment this latency is treated as Normal latency.\r\n     */\r\n    CostDeferred: 2 /* EventLatencyValue.CostDeferred */,\r\n    /**\r\n     * Real time latency.\r\n     */\r\n    RealTime: 3 /* EventLatencyValue.RealTime */,\r\n    /**\r\n     * Bypass normal batching/timing and send as soon as possible, this will still send asynchronously.\r\n     * Added in v3.1.1\r\n     */\r\n    Immediate: 4 /* EventLatencyValue.Immediate */\r\n});\r\n/**\r\n * Enum for property types.\r\n */\r\nexport var EventPropertyType = createEnumStyle({\r\n    Unspecified: 0 /* eEventPropertyType.Unspecified */,\r\n    String: 1 /* eEventPropertyType.String */,\r\n    Int32: 2 /* eEventPropertyType.Int32 */,\r\n    UInt32: 3 /* eEventPropertyType.UInt32 */,\r\n    Int64: 4 /* eEventPropertyType.Int64 */,\r\n    UInt64: 5 /* eEventPropertyType.UInt64 */,\r\n    Double: 6 /* eEventPropertyType.Double */,\r\n    Bool: 7 /* eEventPropertyType.Bool */,\r\n    Guid: 8 /* eEventPropertyType.Guid */,\r\n    DateTime: 9 /* eEventPropertyType.DateTime */\r\n});\r\n/**\r\n * The EventPersistence contains a set of values that specify the event's persistence.\r\n */\r\nexport var EventPersistence = createEnumStyle({\r\n    /**\r\n     * Normal persistence.\r\n     */\r\n    Normal: 1 /* EventPersistenceValue.Normal */,\r\n    /**\r\n     * Critical persistence.\r\n     */\r\n    Critical: 2 /* EventPersistenceValue.Critical */\r\n});\r\nexport var TraceLevel = createEnumStyle({\r\n    NONE: 0 /* eTraceLevel.NONE */,\r\n    ERROR: 1 /* eTraceLevel.ERROR */,\r\n    WARNING: 2 /* eTraceLevel.WARNING */,\r\n    INFORMATION: 3 /* eTraceLevel.INFORMATION */\r\n});\r\nexport var _ExtendedInternalMessageId = objFreeze(__assign(__assign({}, _InternalMessageId), createEnumStyle({\r\n    AuthHandShakeError: 501 /* _eExtendedInternalMessageId.AuthHandShakeError */,\r\n    AuthRedirectFail: 502 /* _eExtendedInternalMessageId.AuthRedirectFail */,\r\n    BrowserCannotReadLocalStorage: 503 /* _eExtendedInternalMessageId.BrowserCannotReadLocalStorage */,\r\n    BrowserCannotWriteLocalStorage: 504 /* _eExtendedInternalMessageId.BrowserCannotWriteLocalStorage */,\r\n    BrowserDoesNotSupportLocalStorage: 505 /* _eExtendedInternalMessageId.BrowserDoesNotSupportLocalStorage */,\r\n    CannotParseBiBlobValue: 506 /* _eExtendedInternalMessageId.CannotParseBiBlobValue */,\r\n    CannotParseDataAttribute: 507 /* _eExtendedInternalMessageId.CannotParseDataAttribute */,\r\n    CVPluginNotAvailable: 508 /* _eExtendedInternalMessageId.CVPluginNotAvailable */,\r\n    DroppedEvent: 509 /* _eExtendedInternalMessageId.DroppedEvent */,\r\n    ErrorParsingAISessionCookie: 510 /* _eExtendedInternalMessageId.ErrorParsingAISessionCookie */,\r\n    ErrorProvidedChannels: 511 /* _eExtendedInternalMessageId.ErrorProvidedChannels */,\r\n    FailedToGetCookies: 512 /* _eExtendedInternalMessageId.FailedToGetCookies */,\r\n    FailedToInitializeCorrelationVector: 513 /* _eExtendedInternalMessageId.FailedToInitializeCorrelationVector */,\r\n    FailedToInitializeSDK: 514 /* _eExtendedInternalMessageId.FailedToInitializeSDK */,\r\n    InvalidContentBlob: 515 /* _eExtendedInternalMessageId.InvalidContentBlob */,\r\n    InvalidCorrelationValue: 516 /* _eExtendedInternalMessageId.InvalidCorrelationValue */,\r\n    SessionRenewalDateIsZero: 517 /* _eExtendedInternalMessageId.SessionRenewalDateIsZero */,\r\n    SendPostOnCompleteFailure: 518 /* _eExtendedInternalMessageId.SendPostOnCompleteFailure */,\r\n    PostResponseHandler: 519 /* _eExtendedInternalMessageId.PostResponseHandler */,\r\n    SDKNotInitialized: 520 /* _eExtendedInternalMessageId.SDKNotInitialized */\r\n})));\r\n//# sourceMappingURL=Enums.js.map","/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n * Index.ts\r\n * @author Abhilash Panwar (abpanwar)\r\n * @copyright Microsoft 2018\r\n * File to export public classes, interfaces and enums.\r\n */\r\nimport { ValueKind, EventLatency, EventPersistence, TraceLevel, EventPropertyType, _ExtendedInternalMessageId } from \"./Enums\";\r\nimport AppInsightsCore from \"./AppInsightsCore\";\r\nimport BaseCore from \"./BaseCore\";\r\nimport ESPromise from \"./ESPromise\";\r\nimport ESPromiseScheduler from \"./ESPromiseScheduler\";\r\nimport { ValueSanitizer } from \"./ValueSanitizer\";\r\nexport { ValueKind, EventLatency, EventPersistence, TraceLevel, AppInsightsCore, BaseCore, _ExtendedInternalMessageId, EventPropertyType, ESPromise, ESPromiseScheduler, ValueSanitizer };\r\nexport { NotificationManager, BaseTelemetryPlugin, ProcessTelemetryContext, MinChannelPriorty, EventsDiscardedReason, DiagnosticLogger, LoggingSeverity, PerfEvent, PerfManager, doPerf, EventHelper, AppInsightsCore as InternalAppInsightsCore, BaseCore as InternalBaseCore, _InternalLogMessage, _InternalMessageId, createEnumStyle, _throwInternal, // _warnToConsole, _logInternalMessage\r\n// The HelperFuncs functions\r\nisTypeof, isUndefined, isNullOrUndefined, hasOwnProperty, isObject, isFunction, attachEvent, detachEvent, normalizeJsName, objForEachKey, strStartsWith, strEndsWith, strContains, strTrim, isDate, isArray, isError, isString, isNumber, isBoolean, toISOString, arrForEach, arrIndexOf, arrMap, arrReduce, objKeys, objDefineAccessors, dateNow, getExceptionName, throwError, setValue, getSetValue, isNotTruthy, isTruthy, proxyAssign, proxyFunctions, proxyFunctionAs, optimizeObject, objCreate, addEventHandler, newGuid, perfNow, newId, generateW3CId, safeGetLogger, objFreeze, objSeal, \r\n// EnvUtils\r\ngetGlobal, getGlobalInst, hasWindow, getWindow, hasDocument, getDocument, getCrypto, getMsCrypto, hasNavigator, getNavigator, hasHistory, getHistory, getLocation, getPerformance, hasJSON, getJSON, isReactNative, getConsole, dumpObj, isIE, getIEVersion, strUndefined, strObject, strPrototype, strFunction, setEnableEnvMocks, strUndefined as Undefined, \r\n// Random\r\nrandomValue, random32, uaDisallowsSameSiteNone as disallowsSameSiteNone, areCookiesSupported, areCookiesSupported as cookieAvailable, createCookieMgr, safeGetCookieMgr, \r\n// Aliases\r\ntoISOString as getISOString, isBeaconsSupported, isFetchSupported, isXhrSupported, useXDomainRequest, addPageHideEventListener, addPageShowEventListener, addEventListeners, addPageUnloadEventListener, removeEventHandler, removeEventListeners, removePageUnloadEventListener, removePageHideEventListener, removePageShowEventListener, eventOn, eventOff, mergeEvtNamespace, createUniqueNamespace, __getRegisteredEvents, createProcessTelemetryContext, createUnloadHandlerContainer, createTraceParent, parseTraceParent, isValidTraceId, isValidSpanId, isValidTraceParent, isSampledFlag, formatTraceParent, findW3cTraceParent } from \"@microsoft/applicationinsights-core-js\";\r\nexport { isValueAssigned, isLatency, isUint8ArrayAvailable, getTenantId, sanitizeProperty, Version, FullVersionString, getCommonSchemaMetaData, getCookie, setCookie, deleteCookie, getCookieValue, extend, createGuid, isDocumentObjectAvailable, isWindowObjectAvailable, setProcessTelemetryTimings, getTime, isArrayValid, isValueKind, getFieldValueType, CoreUtils, disableCookies, // exporting the overridden version for tree-shaking\r\nUtils, // Replacement for import * as Utils from \"./Utils\";\r\nisChromium, // Replace with ai-core version once published in ai-core\r\nopenXhr } from \"./Utils\";\r\n//# sourceMappingURL=Index.js.map","/*\n * 1DS JS SDK Core, 3.2.3\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\nimport { isNullOrUndefined, objForEachKey, isString } from \"@microsoft/applicationinsights-core-js\";\r\nimport { isValueKind, isValueAssigned, getFieldValueType } from \"./Utils\";\r\nvar ValueSanitizer = /** @class */ (function () {\r\n    function ValueSanitizer(fieldSanitizerProvider) {\r\n        var _self = this;\r\n        // To aid with performance this is a lookup map to check if the field value sanitizer supports this field\r\n        var _sanitizerMap = {};\r\n        var _sanitizers = [];\r\n        var _fieldSanitizers = [];\r\n        if (fieldSanitizerProvider) {\r\n            _fieldSanitizers.push(fieldSanitizerProvider);\r\n        }\r\n        function _getFieldSanitizer(path, name) {\r\n            var result;\r\n            var fieldLookup = _sanitizerMap[path];\r\n            if (fieldLookup) {\r\n                result = fieldLookup[name];\r\n            }\r\n            if (!result && result !== null) {\r\n                // Null is a valid result indicating that the value sanitizer does not support this field\r\n                if (isString(path) && isString(name)) {\r\n                    if (_fieldSanitizers.length > 0) {\r\n                        for (var lp = 0; lp < _fieldSanitizers.length; lp++) {\r\n                            if (_fieldSanitizers[lp].handleField(path, name)) {\r\n                                result = {\r\n                                    canHandle: true,\r\n                                    fieldHandler: _fieldSanitizers[lp]\r\n                                };\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (_sanitizers.length === 0) {\r\n                        // Special use-case where there is no sanitizer to pass on to, so just resolving the field\r\n                        // and returning the resulting value (same as sanitizeProperty())\r\n                        result = {\r\n                            canHandle: true\r\n                        };\r\n                    }\r\n                }\r\n                // We still don't have a handler so lets lookup the providers\r\n                if (!result && result !== null) {\r\n                    // Setting the result to null -- which means we and any contained sanitizers can't handle this field\r\n                    result = null;\r\n                    for (var lp = 0; lp < _sanitizers.length; lp++) {\r\n                        if (_sanitizers[lp].handleField(path, name)) {\r\n                            result = {\r\n                                canHandle: true,\r\n                                handler: _sanitizers[lp],\r\n                                fieldHandler: null\r\n                            };\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!fieldLookup) {\r\n                    fieldLookup = _sanitizerMap[path] = {};\r\n                }\r\n                fieldLookup[name] = result;\r\n            }\r\n            return result;\r\n        }\r\n        _self.addSanitizer = function (newSanitizer) {\r\n            if (newSanitizer) {\r\n                _sanitizers.push(newSanitizer);\r\n                // Invalidate any previously mapped fields\r\n                _sanitizerMap = {};\r\n            }\r\n        };\r\n        _self.addFieldSanitizer = function (fieldSanitizer) {\r\n            if (fieldSanitizer) {\r\n                _fieldSanitizers.push(fieldSanitizer);\r\n                // Invalidate any previously mapped fields\r\n                _sanitizerMap = {};\r\n            }\r\n        };\r\n        _self.handleField = function (path, name) {\r\n            var mapValue = _getFieldSanitizer(path, name);\r\n            return mapValue ? mapValue.canHandle : false;\r\n        };\r\n        _self.value = function (path, name, value, stringifyObjects) {\r\n            var mapValue = _getFieldSanitizer(path, name);\r\n            if (mapValue && mapValue.canHandle) {\r\n                if (!mapValue || !mapValue.canHandle) {\r\n                    return null;\r\n                }\r\n                if (mapValue.handler) {\r\n                    // This value sanitizer can't handle this field so pass it only the next one\r\n                    return mapValue.handler.value(path, name, value, stringifyObjects);\r\n                }\r\n                // Check that property is valid\r\n                if (!isString(name) || isNullOrUndefined(value) || value === \"\") {\r\n                    return null;\r\n                }\r\n                var property = null;\r\n                var fieldType = getFieldValueType(value);\r\n                if ((fieldType & 8192 /* FieldValueSanitizerType.EventProperty */) === 8192 /* FieldValueSanitizerType.EventProperty */) {\r\n                    var subType = fieldType & ~8192 /* FieldValueSanitizerType.EventProperty */;\r\n                    property = value;\r\n                    if (!isValueAssigned(property.value) ||\r\n                        (subType !== 1 /* FieldValueSanitizerType.String */ &&\r\n                            subType !== 2 /* FieldValueSanitizerType.Number */ &&\r\n                            subType !== 3 /* FieldValueSanitizerType.Boolean */ &&\r\n                            (subType & 4096 /* FieldValueSanitizerType.Array */) !== 4096 /* FieldValueSanitizerType.Array */)) {\r\n                        // Not a supported IEventProperty type to be able to sanitize\r\n                        return null;\r\n                    }\r\n                }\r\n                else if (fieldType === 1 /* FieldValueSanitizerType.String */ ||\r\n                    fieldType === 2 /* FieldValueSanitizerType.Number */ ||\r\n                    fieldType === 3 /* FieldValueSanitizerType.Boolean */ ||\r\n                    (fieldType & 4096 /* FieldValueSanitizerType.Array */) === 4096 /* FieldValueSanitizerType.Array */) {\r\n                    // If the property isn't IEventProperty (and is either string, number, boolean or array), convert it into one.\r\n                    property = _convertToProperty(path, name, value);\r\n                }\r\n                else if (fieldType === 4 /* FieldValueSanitizerType.Object */) {\r\n                    property = _convertToProperty(path, name, !!stringifyObjects ? JSON.stringify(value) : value);\r\n                }\r\n                if (property) {\r\n                    return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        _self.property = function (path, name, property, stringifyObjects) {\r\n            var mapValue = _getFieldSanitizer(path, name);\r\n            if (!mapValue || !mapValue.canHandle) {\r\n                return null;\r\n            }\r\n            // Check that property is valid\r\n            if (!isString(name) || isNullOrUndefined(property) || !isValueAssigned(property.value)) {\r\n                return null;\r\n            }\r\n            var fieldType = getFieldValueType(property.value);\r\n            if (fieldType === 0 /* FieldValueSanitizerType.NotSet */) {\r\n                // Not a supported field that we can sanitize or serialize\r\n                return null;\r\n            }\r\n            return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);\r\n        };\r\n        function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {\r\n            if (mapValue.handler) {\r\n                // This value sanitizer can't handle this field so pass it only the next one\r\n                return mapValue.handler.property(path, name, property, stringifyObjects);\r\n            }\r\n            // If either pii or cc is set convert value to string (since only string pii/cc is allowed).\r\n            // If the value is a complex type like an array that can't be converted to string we will drop\r\n            // the property.\r\n            if (!isNullOrUndefined(property.kind)) {\r\n                if ((fieldType & 4096 /* FieldValueSanitizerType.Array */) === 4096 /* FieldValueSanitizerType.Array */ || !isValueKind(property.kind)) {\r\n                    return null;\r\n                }\r\n                // Convert the value to a string and assign back to the original value\r\n                property.value = property.value.toString();\r\n            }\r\n            return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);\r\n        }\r\n        function _convertToProperty(path, name, value) {\r\n            if (isValueAssigned(value)) {\r\n                return { value: value };\r\n            }\r\n            return null;\r\n        }\r\n        function _callFieldSanitizer(fieldProvider, path, name, theType, property) {\r\n            if (property && fieldProvider) {\r\n                var sanitizer = fieldProvider.getSanitizer(path, name, theType, property.kind, property.propertyType);\r\n                if (sanitizer) {\r\n                    // This is where we the field will call the handler to \"scrub\" the value. This the primary hook for the ClientHashing Plugin to\r\n                    // be able to apply the hashFunc() / Sha256 conversion of the properties value\r\n                    if (theType === 4 /* FieldValueSanitizerType.Object */) {\r\n                        // Special case of an embedded object (ext.metadata, data.properties)\r\n                        var newValue_1 = {};\r\n                        var propValue = property.value;\r\n                        objForEachKey(propValue, function (propKey, theValue) {\r\n                            var newPath = path + \".\" + name;\r\n                            if (isValueAssigned(theValue)) {\r\n                                var newProp = _convertToProperty(newPath, propKey, theValue);\r\n                                newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, getFieldValueType(theValue), newProp);\r\n                                if (newProp) {\r\n                                    newValue_1[propKey] = newProp.value;\r\n                                }\r\n                            }\r\n                        });\r\n                        property.value = newValue_1;\r\n                    }\r\n                    else {\r\n                        var details = {\r\n                            path: path,\r\n                            name: name,\r\n                            type: theType,\r\n                            prop: property,\r\n                            sanitizer: _self\r\n                        };\r\n                        property = sanitizer.call(_self, details);\r\n                    }\r\n                }\r\n            }\r\n            return property;\r\n        }\r\n    }\r\n    ValueSanitizer.getFieldType = getFieldValueType;\r\n    return ValueSanitizer;\r\n}());\r\nexport { ValueSanitizer };\r\n//# sourceMappingURL=ValueSanitizer.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\r\n\r\nimport { createEnumStyle } from \"../JavaScriptSDK.Enums/EnumHelperFuncs\";\r\nexport var LoggingSeverity = createEnumStyle({\r\n    CRITICAL: 1 /* eLoggingSeverity.CRITICAL */,\r\n    WARNING: 2 /* eLoggingSeverity.WARNING */\r\n});\r\n/**\r\n * Internal message ID. Please create a new one for every conceptually different message. Please keep alphabetically ordered\r\n */\r\nexport var _InternalMessageId = createEnumStyle({\r\n    // Non user actionable\r\n    BrowserDoesNotSupportLocalStorage: 0 /* _eInternalMessageId.BrowserDoesNotSupportLocalStorage */,\r\n    BrowserCannotReadLocalStorage: 1 /* _eInternalMessageId.BrowserCannotReadLocalStorage */,\r\n    BrowserCannotReadSessionStorage: 2 /* _eInternalMessageId.BrowserCannotReadSessionStorage */,\r\n    BrowserCannotWriteLocalStorage: 3 /* _eInternalMessageId.BrowserCannotWriteLocalStorage */,\r\n    BrowserCannotWriteSessionStorage: 4 /* _eInternalMessageId.BrowserCannotWriteSessionStorage */,\r\n    BrowserFailedRemovalFromLocalStorage: 5 /* _eInternalMessageId.BrowserFailedRemovalFromLocalStorage */,\r\n    BrowserFailedRemovalFromSessionStorage: 6 /* _eInternalMessageId.BrowserFailedRemovalFromSessionStorage */,\r\n    CannotSendEmptyTelemetry: 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */,\r\n    ClientPerformanceMathError: 8 /* _eInternalMessageId.ClientPerformanceMathError */,\r\n    ErrorParsingAISessionCookie: 9 /* _eInternalMessageId.ErrorParsingAISessionCookie */,\r\n    ErrorPVCalc: 10 /* _eInternalMessageId.ErrorPVCalc */,\r\n    ExceptionWhileLoggingError: 11 /* _eInternalMessageId.ExceptionWhileLoggingError */,\r\n    FailedAddingTelemetryToBuffer: 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */,\r\n    FailedMonitorAjaxAbort: 13 /* _eInternalMessageId.FailedMonitorAjaxAbort */,\r\n    FailedMonitorAjaxDur: 14 /* _eInternalMessageId.FailedMonitorAjaxDur */,\r\n    FailedMonitorAjaxOpen: 15 /* _eInternalMessageId.FailedMonitorAjaxOpen */,\r\n    FailedMonitorAjaxRSC: 16 /* _eInternalMessageId.FailedMonitorAjaxRSC */,\r\n    FailedMonitorAjaxSend: 17 /* _eInternalMessageId.FailedMonitorAjaxSend */,\r\n    FailedMonitorAjaxGetCorrelationHeader: 18 /* _eInternalMessageId.FailedMonitorAjaxGetCorrelationHeader */,\r\n    FailedToAddHandlerForOnBeforeUnload: 19 /* _eInternalMessageId.FailedToAddHandlerForOnBeforeUnload */,\r\n    FailedToSendQueuedTelemetry: 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */,\r\n    FailedToReportDataLoss: 21 /* _eInternalMessageId.FailedToReportDataLoss */,\r\n    FlushFailed: 22 /* _eInternalMessageId.FlushFailed */,\r\n    MessageLimitPerPVExceeded: 23 /* _eInternalMessageId.MessageLimitPerPVExceeded */,\r\n    MissingRequiredFieldSpecification: 24 /* _eInternalMessageId.MissingRequiredFieldSpecification */,\r\n    NavigationTimingNotSupported: 25 /* _eInternalMessageId.NavigationTimingNotSupported */,\r\n    OnError: 26 /* _eInternalMessageId.OnError */,\r\n    SessionRenewalDateIsZero: 27 /* _eInternalMessageId.SessionRenewalDateIsZero */,\r\n    SenderNotInitialized: 28 /* _eInternalMessageId.SenderNotInitialized */,\r\n    StartTrackEventFailed: 29 /* _eInternalMessageId.StartTrackEventFailed */,\r\n    StopTrackEventFailed: 30 /* _eInternalMessageId.StopTrackEventFailed */,\r\n    StartTrackFailed: 31 /* _eInternalMessageId.StartTrackFailed */,\r\n    StopTrackFailed: 32 /* _eInternalMessageId.StopTrackFailed */,\r\n    TelemetrySampledAndNotSent: 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */,\r\n    TrackEventFailed: 34 /* _eInternalMessageId.TrackEventFailed */,\r\n    TrackExceptionFailed: 35 /* _eInternalMessageId.TrackExceptionFailed */,\r\n    TrackMetricFailed: 36 /* _eInternalMessageId.TrackMetricFailed */,\r\n    TrackPVFailed: 37 /* _eInternalMessageId.TrackPVFailed */,\r\n    TrackPVFailedCalc: 38 /* _eInternalMessageId.TrackPVFailedCalc */,\r\n    TrackTraceFailed: 39 /* _eInternalMessageId.TrackTraceFailed */,\r\n    TransmissionFailed: 40 /* _eInternalMessageId.TransmissionFailed */,\r\n    FailedToSetStorageBuffer: 41 /* _eInternalMessageId.FailedToSetStorageBuffer */,\r\n    FailedToRestoreStorageBuffer: 42 /* _eInternalMessageId.FailedToRestoreStorageBuffer */,\r\n    InvalidBackendResponse: 43 /* _eInternalMessageId.InvalidBackendResponse */,\r\n    FailedToFixDepricatedValues: 44 /* _eInternalMessageId.FailedToFixDepricatedValues */,\r\n    InvalidDurationValue: 45 /* _eInternalMessageId.InvalidDurationValue */,\r\n    TelemetryEnvelopeInvalid: 46 /* _eInternalMessageId.TelemetryEnvelopeInvalid */,\r\n    CreateEnvelopeError: 47 /* _eInternalMessageId.CreateEnvelopeError */,\r\n    // User actionable\r\n    CannotSerializeObject: 48 /* _eInternalMessageId.CannotSerializeObject */,\r\n    CannotSerializeObjectNonSerializable: 49 /* _eInternalMessageId.CannotSerializeObjectNonSerializable */,\r\n    CircularReferenceDetected: 50 /* _eInternalMessageId.CircularReferenceDetected */,\r\n    ClearAuthContextFailed: 51 /* _eInternalMessageId.ClearAuthContextFailed */,\r\n    ExceptionTruncated: 52 /* _eInternalMessageId.ExceptionTruncated */,\r\n    IllegalCharsInName: 53 /* _eInternalMessageId.IllegalCharsInName */,\r\n    ItemNotInArray: 54 /* _eInternalMessageId.ItemNotInArray */,\r\n    MaxAjaxPerPVExceeded: 55 /* _eInternalMessageId.MaxAjaxPerPVExceeded */,\r\n    MessageTruncated: 56 /* _eInternalMessageId.MessageTruncated */,\r\n    NameTooLong: 57 /* _eInternalMessageId.NameTooLong */,\r\n    SampleRateOutOfRange: 58 /* _eInternalMessageId.SampleRateOutOfRange */,\r\n    SetAuthContextFailed: 59 /* _eInternalMessageId.SetAuthContextFailed */,\r\n    SetAuthContextFailedAccountName: 60 /* _eInternalMessageId.SetAuthContextFailedAccountName */,\r\n    StringValueTooLong: 61 /* _eInternalMessageId.StringValueTooLong */,\r\n    StartCalledMoreThanOnce: 62 /* _eInternalMessageId.StartCalledMoreThanOnce */,\r\n    StopCalledWithoutStart: 63 /* _eInternalMessageId.StopCalledWithoutStart */,\r\n    TelemetryInitializerFailed: 64 /* _eInternalMessageId.TelemetryInitializerFailed */,\r\n    TrackArgumentsNotSpecified: 65 /* _eInternalMessageId.TrackArgumentsNotSpecified */,\r\n    UrlTooLong: 66 /* _eInternalMessageId.UrlTooLong */,\r\n    SessionStorageBufferFull: 67 /* _eInternalMessageId.SessionStorageBufferFull */,\r\n    CannotAccessCookie: 68 /* _eInternalMessageId.CannotAccessCookie */,\r\n    IdTooLong: 69 /* _eInternalMessageId.IdTooLong */,\r\n    InvalidEvent: 70 /* _eInternalMessageId.InvalidEvent */,\r\n    FailedMonitorAjaxSetRequestHeader: 71 /* _eInternalMessageId.FailedMonitorAjaxSetRequestHeader */,\r\n    SendBrowserInfoOnUserInit: 72 /* _eInternalMessageId.SendBrowserInfoOnUserInit */,\r\n    PluginException: 73 /* _eInternalMessageId.PluginException */,\r\n    NotificationException: 74 /* _eInternalMessageId.NotificationException */,\r\n    SnippetScriptLoadFailure: 99 /* _eInternalMessageId.SnippetScriptLoadFailure */,\r\n    InvalidInstrumentationKey: 100 /* _eInternalMessageId.InvalidInstrumentationKey */,\r\n    CannotParseAiBlobValue: 101 /* _eInternalMessageId.CannotParseAiBlobValue */,\r\n    InvalidContentBlob: 102 /* _eInternalMessageId.InvalidContentBlob */,\r\n    TrackPageActionEventFailed: 103 /* _eInternalMessageId.TrackPageActionEventFailed */,\r\n    FailedAddingCustomDefinedRequestContext: 104 /* _eInternalMessageId.FailedAddingCustomDefinedRequestContext */,\r\n    InMemoryStorageBufferFull: 105 /* _eInternalMessageId.InMemoryStorageBufferFull */,\r\n    InstrumentationKeyDeprecation: 106 /* _eInternalMessageId.InstrumentationKeyDeprecation */\r\n});\r\n//# sourceMappingURL=LoggingEnums.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\"use strict\";\r\nexport var MinChannelPriorty = 100;\r\n//# sourceMappingURL=IChannelControls.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport { __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\r\nimport { BaseCore } from \"./BaseCore\";\r\nimport { NotificationManager } from \"./NotificationManager\";\r\nimport { doPerf } from \"./PerfManager\";\r\nimport { DiagnosticLogger } from \"./DiagnosticLogger\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { isNullOrUndefined, throwError } from \"./HelperFuncs\";\r\nvar AppInsightsCore = /** @class */ (function (_super) {\r\n    __extends(AppInsightsCore, _super);\r\n    function AppInsightsCore() {\r\n        var _this = _super.call(this) || this;\r\n        dynamicProto(AppInsightsCore, _this, function (_self, _base) {\r\n            _self.initialize = function (config, extensions, logger, notificationManager) {\r\n                _base.initialize(config, extensions, logger || new DiagnosticLogger(config), notificationManager || new NotificationManager(config));\r\n            };\r\n            _self.track = function (telemetryItem) {\r\n                doPerf(_self.getPerfMgr(), function () { return \"AppInsightsCore:track\"; }, function () {\r\n                    if (telemetryItem === null) {\r\n                        _notifyInvalidEvent(telemetryItem);\r\n                        // throw error\r\n                        throwError(\"Invalid telemetry item\");\r\n                    }\r\n                    // do basic validation before sending it through the pipeline\r\n                    _validateTelemetryItem(telemetryItem);\r\n                    _base.track(telemetryItem);\r\n                }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));\r\n            };\r\n            function _validateTelemetryItem(telemetryItem) {\r\n                if (isNullOrUndefined(telemetryItem.name)) {\r\n                    _notifyInvalidEvent(telemetryItem);\r\n                    throwError(\"telemetry name required\");\r\n                }\r\n            }\r\n            function _notifyInvalidEvent(telemetryItem) {\r\n                var manager = _self.getNotifyMgr();\r\n                if (manager) {\r\n                    manager.eventsDiscarded([telemetryItem], 2 /* eEventsDiscardedReason.InvalidEvent */);\r\n                }\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n// Removed Stub for AppInsightsCore.prototype.initialize.\r\n// Removed Stub for AppInsightsCore.prototype.track.\r\n    return AppInsightsCore;\r\n}(BaseCore));\r\nexport { AppInsightsCore };\r\n//# sourceMappingURL=AppInsightsCore.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\r\n\r\n\"use strict\";\r\nimport { __spreadArrayFn as __spreadArray } from \"@microsoft/applicationinsights-shims\";\r\nimport { objCreateFn } from \"@microsoft/applicationinsights-shims\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext, createTelemetryProxyChain } from \"./ProcessTelemetryContext\";\r\nimport { createDistributedTraceContext, initializePlugins, sortPlugins, _getPluginState } from \"./TelemetryHelpers\";\r\nimport { getGblPerfMgr, PerfManager } from \"./PerfManager\";\r\nimport { createCookieMgr } from \"./CookieMgr\";\r\nimport { arrForEach, isNullOrUndefined, getSetValue, setValue, isNotTruthy, isFunction, objExtend, objFreeze, proxyFunctionAs, proxyFunctions, throwError, toISOString, arrIndexOf } from \"./HelperFuncs\";\r\nimport { strExtensionConfig, strIKey } from \"./Constants\";\r\nimport { DiagnosticLogger, _InternalLogMessage, _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\r\nimport { getDebugListener } from \"./DbgExtensionUtils\";\r\nimport { ChannelControllerPriority, createChannelControllerPlugin, createChannelQueues } from \"./ChannelController\";\r\nimport { TelemetryInitializerPlugin } from \"./TelemetryInitializerPlugin\";\r\nimport { createUniqueNamespace } from \"./DataCacheHelper\";\r\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\r\nimport { strAddNotificationListener, strDisabled, strEventsDiscarded, strEventsSendRequest, strEventsSent, strRemoveNotificationListener, strTeardown } from \"./InternalConstants\";\r\nvar strValidationError = \"Plugins must provide initialize method\";\r\nvar strNotificationManager = \"_notificationManager\";\r\nvar strSdkUnloadingError = \"SDK is still unloading...\";\r\nvar strSdkNotInitialized = \"SDK is not initialized\";\r\n// const strPluginUnloadFailed = \"Failed to unload plugin\";\r\nvar defaultInitConfig = {\r\n    // Have the Diagnostic Logger default to log critical errors to the console\r\n    loggingLevelConsole: 1 /* eLoggingSeverity.CRITICAL */\r\n};\r\n/**\r\n * Helper to create the default performance manager\r\n * @param core\r\n * @param notificationMgr\r\n */\r\nfunction _createPerfManager(core, notificationMgr) {\r\n    return new PerfManager(notificationMgr);\r\n}\r\nfunction _validateExtensions(logger, channelPriority, allExtensions) {\r\n    // Concat all available extensions\r\n    var coreExtensions = [];\r\n    // Check if any two extensions have the same priority, then warn to console\r\n    // And extract the local extensions from the\r\n    var extPriorities = {};\r\n    // Extension validation\r\n    arrForEach(allExtensions, function (ext) {\r\n        if (isNullOrUndefined(ext) || isNullOrUndefined(ext.initialize)) {\r\n            throwError(strValidationError);\r\n        }\r\n        var extPriority = ext.priority;\r\n        var identifier = ext.identifier;\r\n        if (ext && extPriority) {\r\n            if (!isNullOrUndefined(extPriorities[extPriority])) {\r\n                _warnToConsole(logger, \"Two extensions have same priority #\" + extPriority + \" - \" + extPriorities[extPriority] + \", \" + identifier);\r\n            }\r\n            else {\r\n                // set a value\r\n                extPriorities[extPriority] = identifier;\r\n            }\r\n        }\r\n        // Split extensions to core and channelController\r\n        if (!extPriority || extPriority < channelPriority) {\r\n            // Add to core extension that will be managed by BaseCore\r\n            coreExtensions.push(ext);\r\n        }\r\n    });\r\n    return {\r\n        all: allExtensions,\r\n        core: coreExtensions\r\n    };\r\n}\r\nfunction _isPluginPresent(thePlugin, plugins) {\r\n    var exists = false;\r\n    arrForEach(plugins, function (plugin) {\r\n        if (plugin === thePlugin) {\r\n            exists = true;\r\n            return -1;\r\n        }\r\n    });\r\n    return exists;\r\n}\r\nfunction _createDummyNotificationManager() {\r\n    var _a;\r\n    return objCreateFn((_a = {},\r\n        _a[strAddNotificationListener] = function (listener) { },\r\n        _a[strRemoveNotificationListener] = function (listener) { },\r\n        _a[strEventsSent] = function (events) { },\r\n        _a[strEventsDiscarded] = function (events, reason) { },\r\n        _a[strEventsSendRequest] = function (sendReason, isAsync) { },\r\n        _a));\r\n}\r\nvar BaseCore = /** @class */ (function () {\r\n    function BaseCore() {\r\n        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\r\n        var _isInitialized;\r\n        var _eventQueue;\r\n        var _notificationManager;\r\n        var _perfManager;\r\n        var _cfgPerfManager;\r\n        var _cookieManager;\r\n        var _pluginChain;\r\n        var _configExtensions;\r\n        var _coreExtensions;\r\n        var _channelControl;\r\n        var _channelConfig;\r\n        var _channelQueue;\r\n        var _isUnloading;\r\n        var _telemetryInitializerPlugin;\r\n        var _internalLogsEventName;\r\n        var _evtNamespace;\r\n        var _unloadHandlers;\r\n        var _debugListener;\r\n        var _traceCtx;\r\n        /**\r\n         * Internal log poller\r\n         */\r\n        var _internalLogPoller = 0;\r\n        dynamicProto(BaseCore, this, function (_self) {\r\n            // Set the default values (also called during teardown)\r\n            _initDefaults();\r\n            _self.isInitialized = function () { return _isInitialized; };\r\n            _self.initialize = function (config, extensions, logger, notificationManager) {\r\n                if (_isUnloading) {\r\n                    throwError(strSdkUnloadingError);\r\n                }\r\n                // Make sure core is only initialized once\r\n                if (_self.isInitialized()) {\r\n                    throwError(\"Core should not be initialized more than once\");\r\n                }\r\n                if (!config || isNullOrUndefined(config.instrumentationKey)) {\r\n                    throwError(\"Please provide instrumentation key\");\r\n                }\r\n                _notificationManager = notificationManager;\r\n                // For backward compatibility only\r\n                _self[strNotificationManager] = notificationManager;\r\n                _self.config = config || {};\r\n                _initDebugListener(config);\r\n                _initPerfManager(config);\r\n                config.extensions = isNullOrUndefined(config.extensions) ? [] : config.extensions;\r\n                // add notification to the extensions in the config so other plugins can access it\r\n                _initExtConfig(config);\r\n                if (logger) {\r\n                    _self.logger = logger;\r\n                }\r\n                // Extension validation\r\n                _configExtensions = [];\r\n                _configExtensions.push.apply(_configExtensions, __spreadArray(__spreadArray([], extensions, false), config.extensions, false));\r\n                _channelConfig = (config || {}).channels;\r\n                _initPluginChain(config, null);\r\n                if (!_channelQueue || _channelQueue.length === 0) {\r\n                    throwError(\"No channels available\");\r\n                }\r\n                _isInitialized = true;\r\n                _self.releaseQueue();\r\n            };\r\n            _self.getTransmissionControls = function () {\r\n                var controls = [];\r\n                if (_channelQueue) {\r\n                    arrForEach(_channelQueue, function (channels) {\r\n                        controls.push(channels.queue);\r\n                    });\r\n                }\r\n                return objFreeze(controls);\r\n            };\r\n            _self.track = function (telemetryItem) {\r\n                // setup default iKey if not passed in\r\n                setValue(telemetryItem, strIKey, _self.config.instrumentationKey, null, isNotTruthy);\r\n                // add default timestamp if not passed in\r\n                setValue(telemetryItem, \"time\", toISOString(new Date()), null, isNotTruthy);\r\n                // Common Schema 4.0\r\n                setValue(telemetryItem, \"ver\", \"4.0\", null, isNullOrUndefined);\r\n                if (!_isUnloading && _self.isInitialized()) {\r\n                    // Process the telemetry plugin chain\r\n                    _createTelCtx().processNext(telemetryItem);\r\n                }\r\n                else {\r\n                    // Queue events until all extensions are initialized\r\n                    _eventQueue.push(telemetryItem);\r\n                }\r\n            };\r\n            _self.getProcessTelContext = _createTelCtx;\r\n            _self.getNotifyMgr = function () {\r\n                if (!_notificationManager) {\r\n                    // Create Dummy notification manager\r\n                    _notificationManager = _createDummyNotificationManager();\r\n                    // For backward compatibility only\r\n                    _self[strNotificationManager] = _notificationManager;\r\n                }\r\n                return _notificationManager;\r\n            };\r\n            /**\r\n             * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n             * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n             * called.\r\n             * @param {INotificationListener} listener - An INotificationListener object.\r\n             */\r\n            _self[strAddNotificationListener] = function (listener) {\r\n                if (_notificationManager) {\r\n                    _notificationManager[strAddNotificationListener](listener);\r\n                }\r\n            };\r\n            /**\r\n             * Removes all instances of the listener.\r\n             * @param {INotificationListener} listener - INotificationListener to remove.\r\n             */\r\n            _self[strRemoveNotificationListener] = function (listener) {\r\n                if (_notificationManager) {\r\n                    _notificationManager[strRemoveNotificationListener](listener);\r\n                }\r\n            };\r\n            _self.getCookieMgr = function () {\r\n                if (!_cookieManager) {\r\n                    _cookieManager = createCookieMgr(_self.config, _self.logger);\r\n                }\r\n                return _cookieManager;\r\n            };\r\n            _self.setCookieMgr = function (cookieMgr) {\r\n                _cookieManager = cookieMgr;\r\n            };\r\n            _self.getPerfMgr = function () {\r\n                if (!_perfManager && !_cfgPerfManager) {\r\n                    if (_self.config && _self.config.enablePerfMgr && isFunction(_self.config.createPerfMgr)) {\r\n                        _cfgPerfManager = _self.config.createPerfMgr(_self, _self.getNotifyMgr());\r\n                    }\r\n                }\r\n                return _perfManager || _cfgPerfManager || getGblPerfMgr();\r\n            };\r\n            _self.setPerfMgr = function (perfMgr) {\r\n                _perfManager = perfMgr;\r\n            };\r\n            _self.eventCnt = function () {\r\n                return _eventQueue.length;\r\n            };\r\n            _self.releaseQueue = function () {\r\n                if (_isInitialized && _eventQueue.length > 0) {\r\n                    var eventQueue = _eventQueue;\r\n                    _eventQueue = [];\r\n                    arrForEach(eventQueue, function (event) {\r\n                        _createTelCtx().processNext(event);\r\n                    });\r\n                }\r\n            };\r\n            /**\r\n             * Periodically check logger.queue for log messages to be flushed\r\n             */\r\n            _self.pollInternalLogs = function (eventName) {\r\n                _internalLogsEventName = eventName || null;\r\n                var interval = _self.config.diagnosticLogInterval;\r\n                if (!interval || !(interval > 0)) {\r\n                    interval = 10000;\r\n                }\r\n                if (_internalLogPoller) {\r\n                    clearInterval(_internalLogPoller);\r\n                }\r\n                _internalLogPoller = setInterval(function () {\r\n                    _flushInternalLogs();\r\n                }, interval);\r\n                return _internalLogPoller;\r\n            };\r\n            /**\r\n             * Stop polling log messages from logger.queue\r\n             */\r\n            _self.stopPollingInternalLogs = function () {\r\n                if (_internalLogPoller) {\r\n                    clearInterval(_internalLogPoller);\r\n                    _internalLogPoller = 0;\r\n                    _flushInternalLogs();\r\n                }\r\n            };\r\n            // Add addTelemetryInitializer\r\n            proxyFunctions(_self, function () { return _telemetryInitializerPlugin; }, [\"addTelemetryInitializer\"]);\r\n            _self.unload = function (isAsync, unloadComplete, cbTimeout) {\r\n                if (isAsync === void 0) { isAsync = true; }\r\n                if (!_isInitialized) {\r\n                    // The SDK is not initialized\r\n                    throwError(strSdkNotInitialized);\r\n                }\r\n                // Check if the SDK still unloading so throw\r\n                if (_isUnloading) {\r\n                    // The SDK is already unloading\r\n                    throwError(strSdkUnloadingError);\r\n                }\r\n                var unloadState = {\r\n                    reason: 50 /* TelemetryUnloadReason.SdkUnload */,\r\n                    isAsync: isAsync,\r\n                    flushComplete: false\r\n                };\r\n                var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);\r\n                processUnloadCtx.onComplete(function () {\r\n                    _initDefaults();\r\n                    unloadComplete && unloadComplete(unloadState);\r\n                }, _self);\r\n                function _doUnload(flushComplete) {\r\n                    unloadState.flushComplete = flushComplete;\r\n                    _isUnloading = true;\r\n                    // Run all of the unload handlers first (before unloading the plugins)\r\n                    _unloadHandlers.run(processUnloadCtx, unloadState);\r\n                    // Stop polling the internal logs\r\n                    _self.stopPollingInternalLogs();\r\n                    // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state\r\n                    processUnloadCtx.processNext(unloadState);\r\n                }\r\n                if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {\r\n                    _doUnload(false);\r\n                }\r\n            };\r\n            _self.getPlugin = _getPlugin;\r\n            _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {\r\n                if (!plugin) {\r\n                    addCb && addCb(false);\r\n                    _logOrThrowError(strValidationError);\r\n                    return;\r\n                }\r\n                var existingPlugin = _getPlugin(plugin.identifier);\r\n                if (existingPlugin && !replaceExisting) {\r\n                    addCb && addCb(false);\r\n                    _logOrThrowError(\"Plugin [\" + plugin.identifier + \"] is already loaded!\");\r\n                    return;\r\n                }\r\n                var updateState = {\r\n                    reason: 16 /* TelemetryUpdateReason.PluginAdded */\r\n                };\r\n                function _addPlugin(removed) {\r\n                    _configExtensions.push(plugin);\r\n                    updateState.added = [plugin];\r\n                    // Re-Initialize the plugin chain\r\n                    _initPluginChain(_self.config, updateState);\r\n                    addCb && addCb(true);\r\n                }\r\n                if (existingPlugin) {\r\n                    var removedPlugins_1 = [existingPlugin.plugin];\r\n                    var unloadState = {\r\n                        reason: 2 /* TelemetryUnloadReason.PluginReplace */,\r\n                        isAsync: !!isAsync\r\n                    };\r\n                    _removePlugins(removedPlugins_1, unloadState, function (removed) {\r\n                        if (!removed) {\r\n                            // Previous plugin was successfully removed or was not installed\r\n                            addCb && addCb(false);\r\n                        }\r\n                        else {\r\n                            updateState.removed = removedPlugins_1;\r\n                            updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;\r\n                            _addPlugin(true);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    _addPlugin(false);\r\n                }\r\n            };\r\n            _self.evtNamespace = function () {\r\n                return _evtNamespace;\r\n            };\r\n            _self.flush = _flushChannels;\r\n            _self.getTraceCtx = function (createNew) {\r\n                if (!_traceCtx) {\r\n                    _traceCtx = createDistributedTraceContext();\r\n                }\r\n                return _traceCtx;\r\n            };\r\n            _self.setTraceCtx = function (traceCtx) {\r\n                _traceCtx = traceCtx || null;\r\n            };\r\n            // Create the addUnloadCb\r\n            proxyFunctionAs(_self, \"addUnloadCb\", function () { return _unloadHandlers; }, \"add\");\r\n            function _initDefaults() {\r\n                _isInitialized = false;\r\n                // Use a default logger so initialization errors are not dropped on the floor with full logging\r\n                _self.config = objExtend(true, {}, defaultInitConfig);\r\n                _self.logger = new DiagnosticLogger(_self.config);\r\n                _self._extensions = [];\r\n                _telemetryInitializerPlugin = new TelemetryInitializerPlugin();\r\n                _eventQueue = [];\r\n                _notificationManager = null;\r\n                _perfManager = null;\r\n                _cfgPerfManager = null;\r\n                _cookieManager = null;\r\n                _pluginChain = null;\r\n                _coreExtensions = null;\r\n                _configExtensions = [];\r\n                _channelControl = null;\r\n                _channelConfig = null;\r\n                _channelQueue = null;\r\n                _isUnloading = false;\r\n                _internalLogsEventName = null;\r\n                _evtNamespace = createUniqueNamespace(\"AIBaseCore\", true);\r\n                _unloadHandlers = createUnloadHandlerContainer();\r\n                _traceCtx = null;\r\n            }\r\n            function _createTelCtx() {\r\n                return createProcessTelemetryContext(_getPluginChain(), _self.config, _self);\r\n            }\r\n            // Initialize or Re-initialize the plugins\r\n            function _initPluginChain(config, updateState) {\r\n                // Extension validation\r\n                var theExtensions = _validateExtensions(_self.logger, ChannelControllerPriority, _configExtensions);\r\n                _coreExtensions = theExtensions.core;\r\n                _pluginChain = null;\r\n                // Sort the complete set of extensions by priority\r\n                var allExtensions = theExtensions.all;\r\n                // Initialize the Channel Queues and the channel plugins first\r\n                _channelQueue = objFreeze(createChannelQueues(_channelConfig, allExtensions, config, _self));\r\n                if (_channelControl) {\r\n                    // During add / remove of a plugin this may get called again, so don't re-add if already present\r\n                    // But we also want the controller as the last, so remove if already present\r\n                    // And reusing the existing instance, just in case an installed plugin has a reference and\r\n                    // is using it.\r\n                    var idx = arrIndexOf(allExtensions, _channelControl);\r\n                    if (idx !== -1) {\r\n                        allExtensions.splice(idx, 1);\r\n                    }\r\n                    idx = arrIndexOf(_coreExtensions, _channelControl);\r\n                    if (idx !== -1) {\r\n                        _coreExtensions.splice(idx, 1);\r\n                    }\r\n                    _channelControl._setQueue(_channelQueue);\r\n                }\r\n                else {\r\n                    _channelControl = createChannelControllerPlugin(_channelQueue, _self);\r\n                }\r\n                // Add on \"channelController\" as the last \"plugin\"\r\n                allExtensions.push(_channelControl);\r\n                _coreExtensions.push(_channelControl);\r\n                // Required to allow plugins to call core.getPlugin() during their own initialization\r\n                _self._extensions = sortPlugins(allExtensions);\r\n                // Initialize the controls\r\n                _channelControl.initialize(config, _self, allExtensions);\r\n                initializePlugins(_createTelCtx(), allExtensions);\r\n                // Now reset the extensions to just those being managed by Basecore\r\n                _self._extensions = objFreeze(sortPlugins(_coreExtensions || [])).slice();\r\n                if (updateState) {\r\n                    _doUpdate(updateState);\r\n                }\r\n            }\r\n            function _getPlugin(pluginIdentifier) {\r\n                var theExt = null;\r\n                var thePlugin = null;\r\n                arrForEach(_self._extensions, function (ext) {\r\n                    if (ext.identifier === pluginIdentifier && ext !== _channelControl && ext !== _telemetryInitializerPlugin) {\r\n                        thePlugin = ext;\r\n                        return -1;\r\n                    }\r\n                });\r\n                if (!thePlugin && _channelControl) {\r\n                    // Check the channel Controller\r\n                    thePlugin = _channelControl.getChannel(pluginIdentifier);\r\n                }\r\n                if (thePlugin) {\r\n                    theExt = {\r\n                        plugin: thePlugin,\r\n                        setEnabled: function (enabled) {\r\n                            _getPluginState(thePlugin)[strDisabled] = !enabled;\r\n                        },\r\n                        isEnabled: function () {\r\n                            var pluginState = _getPluginState(thePlugin);\r\n                            return !pluginState[strTeardown] && !pluginState[strDisabled];\r\n                        },\r\n                        remove: function (isAsync, removeCb) {\r\n                            if (isAsync === void 0) { isAsync = true; }\r\n                            var pluginsToRemove = [thePlugin];\r\n                            var unloadState = {\r\n                                reason: 1 /* TelemetryUnloadReason.PluginUnload */,\r\n                                isAsync: isAsync\r\n                            };\r\n                            _removePlugins(pluginsToRemove, unloadState, function (removed) {\r\n                                if (removed) {\r\n                                    // Re-Initialize the plugin chain\r\n                                    _initPluginChain(_self.config, {\r\n                                        reason: 32 /* TelemetryUpdateReason.PluginRemoved */,\r\n                                        removed: pluginsToRemove\r\n                                    });\r\n                                }\r\n                                removeCb && removeCb(removed);\r\n                            });\r\n                        }\r\n                    };\r\n                }\r\n                return theExt;\r\n            }\r\n            function _getPluginChain() {\r\n                if (!_pluginChain) {\r\n                    // copy the collection of extensions\r\n                    var extensions = (_coreExtensions || []).slice();\r\n                    // During add / remove this may get called again, so don't readd if already present\r\n                    if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {\r\n                        extensions.push(_telemetryInitializerPlugin);\r\n                    }\r\n                    _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _self.config, _self);\r\n                }\r\n                return _pluginChain;\r\n            }\r\n            function _removePlugins(thePlugins, unloadState, removeComplete) {\r\n                if (thePlugins && thePlugins.length > 0) {\r\n                    var unloadChain = createTelemetryProxyChain(thePlugins, _self.config, _self);\r\n                    var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);\r\n                    unloadCtx.onComplete(function () {\r\n                        var removed = false;\r\n                        // Remove the listed config extensions\r\n                        var newConfigExtensions = [];\r\n                        arrForEach(_configExtensions, function (plugin, idx) {\r\n                            if (!_isPluginPresent(plugin, thePlugins)) {\r\n                                newConfigExtensions.push(plugin);\r\n                            }\r\n                            else {\r\n                                removed = true;\r\n                            }\r\n                        });\r\n                        _configExtensions = newConfigExtensions;\r\n                        // Re-Create the channel config\r\n                        var newChannelConfig = [];\r\n                        if (_channelConfig) {\r\n                            arrForEach(_channelConfig, function (queue, idx) {\r\n                                var newQueue = [];\r\n                                arrForEach(queue, function (channel) {\r\n                                    if (!_isPluginPresent(channel, thePlugins)) {\r\n                                        newQueue.push(channel);\r\n                                    }\r\n                                    else {\r\n                                        removed = true;\r\n                                    }\r\n                                });\r\n                                newChannelConfig.push(newQueue);\r\n                            });\r\n                            _channelConfig = newChannelConfig;\r\n                        }\r\n                        removeComplete && removeComplete(removed);\r\n                    });\r\n                    unloadCtx.processNext(unloadState);\r\n                }\r\n                else {\r\n                    removeComplete(false);\r\n                }\r\n            }\r\n            function _flushInternalLogs() {\r\n                var queue = _self.logger ? _self.logger.queue : [];\r\n                if (queue) {\r\n                    arrForEach(queue, function (logMessage) {\r\n                        var item = {\r\n                            name: _internalLogsEventName ? _internalLogsEventName : \"InternalMessageId: \" + logMessage.messageId,\r\n                            iKey: _self.config.instrumentationKey,\r\n                            time: toISOString(new Date()),\r\n                            baseType: _InternalLogMessage.dataType,\r\n                            baseData: { message: logMessage.message }\r\n                        };\r\n                        _self.track(item);\r\n                    });\r\n                    queue.length = 0;\r\n                }\r\n            }\r\n            function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {\r\n                if (_channelControl) {\r\n                    return _channelControl.flush(isAsync, callBack, sendReason || 6 /* SendRequestReason.SdkUnload */, cbTimeout);\r\n                }\r\n                callBack && callBack(false);\r\n                return true;\r\n            }\r\n            function _initDebugListener(config) {\r\n                if (config.disableDbgExt === true && _debugListener) {\r\n                    // Remove any previously loaded debug listener\r\n                    _notificationManager[strRemoveNotificationListener](_debugListener);\r\n                    _debugListener = null;\r\n                }\r\n                if (_notificationManager && !_debugListener && config.disableDbgExt !== true) {\r\n                    _debugListener = getDebugListener(config);\r\n                    _notificationManager[strAddNotificationListener](_debugListener);\r\n                }\r\n            }\r\n            function _initPerfManager(config) {\r\n                if (!config.enablePerfMgr && _cfgPerfManager) {\r\n                    // Remove any existing config based performance manager\r\n                    _cfgPerfManager = null;\r\n                }\r\n                if (config.enablePerfMgr) {\r\n                    // Set the performance manager creation function if not defined\r\n                    setValue(_self.config, \"createPerfMgr\", _createPerfManager);\r\n                }\r\n            }\r\n            function _initExtConfig(config) {\r\n                var extConfig = getSetValue(config, strExtensionConfig);\r\n                extConfig.NotificationManager = _notificationManager;\r\n            }\r\n            function _doUpdate(updateState) {\r\n                var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);\r\n                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {\r\n                    updateCtx.processNext(updateState);\r\n                }\r\n            }\r\n            function _logOrThrowError(message) {\r\n                var logger = _self.logger;\r\n                if (logger) {\r\n                    // there should always be a logger\r\n                    _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);\r\n                }\r\n                else {\r\n                    throwError(message);\r\n                }\r\n            }\r\n        });\r\n    }\r\n// Removed Stub for BaseCore.prototype.initialize.\r\n// Removed Stub for BaseCore.prototype.getTransmissionControls.\r\n// Removed Stub for BaseCore.prototype.track.\r\n// Removed Stub for BaseCore.prototype.getProcessTelContext.\r\n// Removed Stub for BaseCore.prototype.getNotifyMgr.\r\n// Removed Stub for BaseCore.prototype.addNotificationListener.\r\n// Removed Stub for BaseCore.prototype.removeNotificationListener.\r\n// Removed Stub for BaseCore.prototype.getCookieMgr.\r\n// Removed Stub for BaseCore.prototype.setCookieMgr.\r\n// Removed Stub for BaseCore.prototype.getPerfMgr.\r\n// Removed Stub for BaseCore.prototype.setPerfMgr.\r\n// Removed Stub for BaseCore.prototype.eventCnt.\r\n// Removed Stub for BaseCore.prototype.pollInternalLogs.\r\n// Removed Stub for BaseCore.prototype.stopPollingInternalLogs.\r\n// Removed Stub for BaseCore.prototype.addTelemetryInitializer.\r\n// Removed Stub for BaseCore.prototype.unload.\r\n// Removed Stub for BaseCore.prototype.getPlugin.\r\n// Removed Stub for BaseCore.prototype.addPlugin.\r\n// Removed Stub for BaseCore.prototype.evtNamespace.\r\n// Removed Stub for BaseCore.prototype.addUnloadCb.\r\n// Removed Stub for BaseCore.prototype.flush.\r\n// Removed Stub for BaseCore.prototype.getTraceCtx.\r\n// Removed Stub for BaseCore.prototype.setTraceCtx.\r\n// Removed Stub for BaseCore.prototype.releaseQueue.\r\n// Removed Stub for BaseCore.prototype._updateHook.\r\n    return BaseCore;\r\n}());\r\nexport { BaseCore };\r\n//# sourceMappingURL=BaseCore.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\r\n// \r\nimport { arrForEach, isArray, objFreeze, throwError } from \"./HelperFuncs\";\r\nimport { strPause, strProcessNext, strResume, strTeardown } from \"./InternalConstants\";\r\nimport { createProcessTelemetryContext, createTelemetryProxyChain } from \"./ProcessTelemetryContext\";\r\nimport { initializePlugins } from \"./TelemetryHelpers\";\r\nexport var ChannelControllerPriority = 500;\r\nvar ChannelValidationMessage = \"Channel has invalid priority - \";\r\nfunction _addChannelQueue(channelQueue, queue, config, core) {\r\n    if (queue && isArray(queue) && queue.length > 0) {\r\n        queue = queue.sort(function (a, b) {\r\n            return a.priority - b.priority;\r\n        });\r\n        arrForEach(queue, function (queueItem) {\r\n            if (queueItem.priority < ChannelControllerPriority) {\r\n                throwError(ChannelValidationMessage + queueItem.identifier);\r\n            }\r\n        });\r\n        channelQueue.push({\r\n            queue: objFreeze(queue),\r\n            chain: createTelemetryProxyChain(queue, config, core)\r\n        });\r\n    }\r\n}\r\nexport function createChannelControllerPlugin(channelQueue, core) {\r\n    var _a;\r\n    function _getTelCtx() {\r\n        return createProcessTelemetryContext(null, core.config, core, null);\r\n    }\r\n    function _processChannelQueue(theChannels, itemCtx, processFn, onComplete) {\r\n        var waiting = theChannels ? (theChannels.length + 1) : 1;\r\n        function _runChainOnComplete() {\r\n            waiting--;\r\n            if (waiting === 0) {\r\n                onComplete && onComplete();\r\n                onComplete = null;\r\n            }\r\n        }\r\n        if (waiting > 0) {\r\n            arrForEach(theChannels, function (channels) {\r\n                // pass on to first item in queue\r\n                if (channels && channels.queue.length > 0) {\r\n                    var channelChain = channels.chain;\r\n                    var chainCtx = itemCtx.createNew(channelChain);\r\n                    chainCtx.onComplete(_runChainOnComplete);\r\n                    // Cause this chain to start processing\r\n                    processFn(chainCtx);\r\n                }\r\n                else {\r\n                    waiting--;\r\n                }\r\n            });\r\n        }\r\n        _runChainOnComplete();\r\n    }\r\n    function _doUpdate(updateCtx, updateState) {\r\n        var theUpdateState = updateState || {\r\n            reason: 0 /* TelemetryUpdateReason.Unknown */\r\n        };\r\n        _processChannelQueue(channelQueue, updateCtx, function (chainCtx) {\r\n            chainCtx[strProcessNext](theUpdateState);\r\n        }, function () {\r\n            updateCtx[strProcessNext](theUpdateState);\r\n        });\r\n        return true;\r\n    }\r\n    function _doTeardown(unloadCtx, unloadState) {\r\n        var theUnloadState = unloadState || {\r\n            reason: 0 /* TelemetryUnloadReason.ManualTeardown */,\r\n            isAsync: false\r\n        };\r\n        _processChannelQueue(channelQueue, unloadCtx, function (chainCtx) {\r\n            chainCtx[strProcessNext](theUnloadState);\r\n        }, function () {\r\n            unloadCtx[strProcessNext](theUnloadState);\r\n            isInitialized = false;\r\n        });\r\n        return true;\r\n    }\r\n    function _getChannel(pluginIdentifier) {\r\n        var thePlugin = null;\r\n        if (channelQueue && channelQueue.length > 0) {\r\n            arrForEach(channelQueue, function (channels) {\r\n                // pass on to first item in queue\r\n                if (channels && channels.queue.length > 0) {\r\n                    arrForEach(channels.queue, function (ext) {\r\n                        if (ext.identifier === pluginIdentifier) {\r\n                            thePlugin = ext;\r\n                            // Cause arrForEach to stop iterating\r\n                            return -1;\r\n                        }\r\n                    });\r\n                    if (thePlugin) {\r\n                        // Cause arrForEach to stop iterating\r\n                        return -1;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return thePlugin;\r\n    }\r\n    var isInitialized = false;\r\n    var channelController = (_a = {\r\n            identifier: \"ChannelControllerPlugin\",\r\n            priority: ChannelControllerPriority,\r\n            initialize: function (config, core, extensions, pluginChain) {\r\n                isInitialized = true;\r\n                arrForEach(channelQueue, function (channels) {\r\n                    if (channels && channels.queue.length > 0) {\r\n                        initializePlugins(createProcessTelemetryContext(channels.chain, config, core), extensions);\r\n                    }\r\n                });\r\n            },\r\n            isInitialized: function () {\r\n                return isInitialized;\r\n            },\r\n            processTelemetry: function (item, itemCtx) {\r\n                _processChannelQueue(channelQueue, itemCtx || _getTelCtx(), function (chainCtx) {\r\n                    chainCtx[strProcessNext](item);\r\n                }, function () {\r\n                    itemCtx[strProcessNext](item);\r\n                });\r\n            },\r\n            update: _doUpdate\r\n        },\r\n        _a[strPause] = function () {\r\n            _processChannelQueue(channelQueue, _getTelCtx(), function (chainCtx) {\r\n                chainCtx.iterate(function (plugin) {\r\n                    plugin[strPause] && plugin[strPause]();\r\n                });\r\n            }, null);\r\n        },\r\n        _a[strResume] = function () {\r\n            _processChannelQueue(channelQueue, _getTelCtx(), function (chainCtx) {\r\n                chainCtx.iterate(function (plugin) {\r\n                    plugin[strResume] && plugin[strResume]();\r\n                });\r\n            }, null);\r\n        },\r\n        _a[strTeardown] = _doTeardown,\r\n        _a.getChannel = _getChannel,\r\n        _a.flush = function (isAsync, callBack, sendReason, cbTimeout) {\r\n            // Setting waiting to one so that we don't call the callBack until we finish iterating\r\n            var waiting = 1;\r\n            var doneIterating = false;\r\n            var cbTimer = null;\r\n            cbTimeout = cbTimeout || 5000;\r\n            function doCallback() {\r\n                waiting--;\r\n                if (doneIterating && waiting === 0) {\r\n                    if (cbTimer) {\r\n                        clearTimeout(cbTimer);\r\n                        cbTimer = null;\r\n                    }\r\n                    callBack && callBack(doneIterating);\r\n                    callBack = null;\r\n                }\r\n            }\r\n            _processChannelQueue(channelQueue, _getTelCtx(), function (chainCtx) {\r\n                chainCtx.iterate(function (plugin) {\r\n                    if (plugin.flush) {\r\n                        waiting++;\r\n                        var handled_1 = false;\r\n                        // Not all channels will call this callback for every scenario\r\n                        if (!plugin.flush(isAsync, function () {\r\n                            handled_1 = true;\r\n                            doCallback();\r\n                        }, sendReason)) {\r\n                            if (!handled_1) {\r\n                                // If any channel doesn't return true and it didn't call the callback, then we should assume that the callback\r\n                                // will never be called, so use a timeout to allow the channel(s) some time to \"finish\" before triggering any\r\n                                // followup function (such as unloading)\r\n                                if (isAsync && cbTimer == null) {\r\n                                    cbTimer = setTimeout(function () {\r\n                                        cbTimer = null;\r\n                                        doCallback();\r\n                                    }, cbTimeout);\r\n                                }\r\n                                else {\r\n                                    doCallback();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }, function () {\r\n                doneIterating = true;\r\n                doCallback();\r\n            });\r\n            return true;\r\n        },\r\n        _a._setQueue = function (queue) {\r\n            channelQueue = queue;\r\n        },\r\n        _a);\r\n    return channelController;\r\n}\r\nexport function createChannelQueues(channels, extensions, config, core) {\r\n    var channelQueue = [];\r\n    if (channels) {\r\n        // Add and sort the configuration channel queues\r\n        arrForEach(channels, function (queue) { return _addChannelQueue(channelQueue, queue, config, core); });\r\n    }\r\n    if (extensions) {\r\n        // Create a new channel queue for any extensions with a priority > the ChannelControllerPriority\r\n        var extensionQueue_1 = [];\r\n        arrForEach(extensions, function (plugin) {\r\n            if (plugin.priority > ChannelControllerPriority) {\r\n                extensionQueue_1.push(plugin);\r\n            }\r\n        });\r\n        _addChannelQueue(channelQueue, extensionQueue_1, config, core);\r\n    }\r\n    return channelQueue;\r\n}\r\n//# sourceMappingURL=ChannelController.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { arrForEach, arrIndexOf } from \"./HelperFuncs\";\r\nimport { strAddNotificationListener, strEventsDiscarded, strEventsSendRequest, strEventsSent, strPerfEvent, strRemoveNotificationListener } from \"./InternalConstants\";\r\nfunction _runListeners(listeners, name, isAsync, callback) {\r\n    arrForEach(listeners, function (listener) {\r\n        if (listener && listener[name]) {\r\n            if (isAsync) {\r\n                setTimeout(function () { return callback(listener); }, 0);\r\n            }\r\n            else {\r\n                try {\r\n                    callback(listener);\r\n                }\r\n                catch (e) {\r\n                    // Catch errors to ensure we don't block sending the requests\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\n * Class to manage sending notifications to all the listeners.\r\n */\r\nvar NotificationManager = /** @class */ (function () {\r\n    function NotificationManager(config) {\r\n        this.listeners = [];\r\n        var perfEvtsSendAll = !!(config || {}).perfEvtsSendAll;\r\n        dynamicProto(NotificationManager, this, function (_self) {\r\n            _self[strAddNotificationListener] = function (listener) {\r\n                _self.listeners.push(listener);\r\n            };\r\n            /**\r\n             * Removes all instances of the listener.\r\n             * @param {INotificationListener} listener - AWTNotificationListener to remove.\r\n             */\r\n            _self[strRemoveNotificationListener] = function (listener) {\r\n                var index = arrIndexOf(_self.listeners, listener);\r\n                while (index > -1) {\r\n                    _self.listeners.splice(index, 1);\r\n                    index = arrIndexOf(_self.listeners, listener);\r\n                }\r\n            };\r\n            /**\r\n             * Notification for events sent.\r\n             * @param {ITelemetryItem[]} events - The array of events that have been sent.\r\n             */\r\n            _self[strEventsSent] = function (events) {\r\n                _runListeners(_self.listeners, strEventsSent, true, function (listener) {\r\n                    listener[strEventsSent](events);\r\n                });\r\n            };\r\n            /**\r\n             * Notification for events being discarded.\r\n             * @param {ITelemetryItem[]} events - The array of events that have been discarded by the SDK.\r\n             * @param {number} reason           - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n             * constant should be used to check the different values.\r\n             */\r\n            _self[strEventsDiscarded] = function (events, reason) {\r\n                _runListeners(_self.listeners, strEventsDiscarded, true, function (listener) {\r\n                    listener[strEventsDiscarded](events, reason);\r\n                });\r\n            };\r\n            /**\r\n             * [Optional] A function called when the events have been requested to be sent to the sever.\r\n             * @param {number} sendReason - The reason why the event batch is being sent.\r\n             * @param {boolean} isAsync   - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n             */\r\n            _self[strEventsSendRequest] = function (sendReason, isAsync) {\r\n                _runListeners(_self.listeners, strEventsSendRequest, isAsync, function (listener) {\r\n                    listener[strEventsSendRequest](sendReason, isAsync);\r\n                });\r\n            };\r\n            _self[strPerfEvent] = function (perfEvent) {\r\n                if (perfEvent) {\r\n                    // Send all events or only parent events\r\n                    if (perfEvtsSendAll || !perfEvent.isChildEvt()) {\r\n                        _runListeners(_self.listeners, strPerfEvent, false, function (listener) {\r\n                            if (perfEvent.isAsync) {\r\n                                setTimeout(function () { return listener[strPerfEvent](perfEvent); }, 0);\r\n                            }\r\n                            else {\r\n                                listener[strPerfEvent](perfEvent);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n        });\r\n    }\r\n// Removed Stub for NotificationManager.prototype.addNotificationListener.\r\n// Removed Stub for NotificationManager.prototype.removeNotificationListener.\r\n// Removed Stub for NotificationManager.prototype.eventsSent.\r\n// Removed Stub for NotificationManager.prototype.eventsDiscarded.\r\n// Removed Stub for NotificationManager.prototype.eventsSendRequest.\r\n    return NotificationManager;\r\n}());\r\nexport { NotificationManager };\r\n//# sourceMappingURL=NotificationManager.js.map","/*\n * Application Insights JavaScript SDK - Core, 2.8.4\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n// \r\n// \r\nimport { __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { BaseTelemetryPlugin } from \"./BaseTelemetryPlugin\";\r\nimport { _throwInternal } from \"./DiagnosticLogger\";\r\nimport { dumpObj } from \"./EnvUtils\";\r\nimport { arrForEach, getExceptionName } from \"./HelperFuncs\";\r\nimport { strDoTeardown } from \"./InternalConstants\";\r\nvar TelemetryInitializerPlugin = /** @class */ (function (_super) {\r\n    __extends(TelemetryInitializerPlugin, _super);\r\n    function TelemetryInitializerPlugin() {\r\n        var _this = _super.call(this) || this;\r\n        _this.identifier = \"TelemetryInitializerPlugin\";\r\n        _this.priority = 199;\r\n        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\r\n        var _id;\r\n        var _initializers;\r\n        _initDefaults();\r\n        dynamicProto(TelemetryInitializerPlugin, _this, function (_self, _base) {\r\n            _self.addTelemetryInitializer = function (telemetryInitializer) {\r\n                var theInitializer = {\r\n                    id: _id++,\r\n                    fn: telemetryInitializer\r\n                };\r\n                _initializers.push(theInitializer);\r\n                var handler = {\r\n                    remove: function () {\r\n                        arrForEach(_initializers, function (initializer, idx) {\r\n                            if (initializer.id === theInitializer.id) {\r\n                                _initializers.splice(idx, 1);\r\n                                return -1;\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                return handler;\r\n            };\r\n            _self.processTelemetry = function (item, itemCtx) {\r\n                var doNotSendItem = false;\r\n                var telemetryInitializersCount = _initializers.length;\r\n                for (var i = 0; i < telemetryInitializersCount; ++i) {\r\n                    var telemetryInitializer = _initializers[i];\r\n                    if (telemetryInitializer) {\r\n                        try {\r\n                            if (telemetryInitializer.fn.apply(null, [item]) === false) {\r\n                                doNotSendItem = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                            // log error but dont stop executing rest of the telemetry initializers\r\n                            // doNotSendItem = true;\r\n                            _throwInternal(itemCtx.diagLog(), 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, \"One of telemetry initializers failed, telemetry item will not be sent: \" + getExceptionName(e), { exception: dumpObj(e) }, true);\r\n                        }\r\n                    }\r\n                }\r\n                if (!doNotSendItem) {\r\n                    _self.processNext(item, itemCtx);\r\n                }\r\n            };\r\n            _self[strDoTeardown] = function () {\r\n                _initDefaults();\r\n            };\r\n        });\r\n        function _initDefaults() {\r\n            _id = 0;\r\n            _initializers = [];\r\n        }\r\n        return _this;\r\n    }\r\n// Removed Stub for TelemetryInitializerPlugin.prototype.addTelemetryInitializer.\r\n// Removed Stub for TelemetryInitializerPlugin.prototype.processTelemetry.\r\n    return TelemetryInitializerPlugin;\r\n}(BaseTelemetryPlugin));\r\nexport { TelemetryInitializerPlugin };\r\n//# sourceMappingURL=TelemetryInitializerPlugin.js.map"],"names":[],"sourceRoot":""}